<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="IDYUPnBNhdnU8o9LRNKZ1RSt14tIxTI0rLeMrBtswXw"><title> Ref objects inside useEffect Hooks · Fish</title><meta name="description" content="Ref objects inside useEffect Hooks - Fish"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/posts/favicon.png"><link rel="stylesheet" href="/posts/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://icyfish.github.io/posts/atom.xml" title="Fish"><meta name="generator" content="Hexo 7.0.0-rc1"></head><body><div class="wrap"><header><a href="/posts/" class="logo-link"><img src="/posts/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/posts/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/posts/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/posts/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="http://twitter.com/icyfish_" target="_blank" class="nav-list-link">TWITTER</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Ref objects inside useEffect Hooks</h1><div class="post-info">Sep 22, 2021</div><div class="post-content"><p>原文: <a href="https://medium.com/@teh_builder/ref-objects-inside-useeffect-hooks-eb7c15198780" target="_blank" rel="noopener">Ref objects inside useEffect Hooks</a></p>
<hr>
<p>当我们要实现一个自定义 hook, 索引到某个 DOM 节点的时候, 你或许首先会想到使用 <code>useRef</code> hook 来实现. 这也是我的首选项.</p>
<p>因此在我初次实现 <a href="https://github.com/thebuilder/react-intersection-observer" target="_blank" rel="noopener">react-intersection-observer</a> 的时候, 就使用了这种实现方式. 但是在实现过程中, 发现了一个很有趣的问题: <a href="https://github.com/thebuilder/react-intersection-observer/issues/162" target="_blank" rel="noopener">如何处理 hooks 的条件渲染?</a>.</p>
<p>最主要的问题之一是, 我以为 <code>ref</code> 始终会有值, 但是实际情况是:</p>
<ul>
<li><code>ref</code> 的初始值是 <code>undefined</code>, 之后才会被赋值.</li>
<li><code>ref</code> 有可能变为另一个完全不同的元素.</li>
<li><code>ref</code> 有可能从一个元素变为 <code>undefined</code>.</li>
</ul>
<p>我的自定义 hook 并没有处理以上任何一种情况.</p>
<h3 id="ref-和-useEffect-的问题"><a href="#ref-和-useEffect-的问题" class="headerlink" title="ref 和 useEffect 的问题"></a>ref 和 useEffect 的问题</h3><p><code>useRef</code> hook 对我们的自定义 hook 来说是一个陷阱, 如果搭配 <code>useEffect</code> 一起使用的话. 你的直觉应该是把 <code>ref.current</code> 加到 <code>useEffect</code> 的依赖参数中, 这样一来, 一旦 <code>ref</code> 变化, <code>useEffect</code> 中的函数也会重新执行.</p>
<p>但问题来了, 只有当组件重新渲染的时候, <code>ref</code>    值才会有所变化, 因此在 <code>useEffect</code> 中, 在下一次渲染完成之前, 都不会捕获到 <code>ref</code> 值的变化.</p>
<p><a href="https://codesandbox.io/s/01m0ok09rv?from-embed" target="_blank" rel="noopener">CodeSandBox示例</a></p>
<p>观察社区中的这些自定义 hooks, 会发现这是一个普遍存在的问题. 一些自定义 hooks 的网站, 比如<a href="https://usehooks.com/" target="_blank" rel="noopener">useHooks</a>, <a href="https://github.com/jaredpalmer/the-platform" target="_blank" rel="noopener">the-platform</a> 都跌入了这个陷阱中, 因为大部分开发者都认为这个 <code>ref</code>, 在第一次渲染之后, 就不会变化了.</p>
<p>于是我<a href="https://twitter.com/teh_builder/status/1093497029693763584?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1093497348913803265%7Ctwgr%5E%7Ctwcon%5Es2_&amp;ref_url=https%3A%2F%2Fcdn.embedly.com%2Fwidgets%2Fmedia.html%3Ftype%3Dtext2Fhtmlkey%3Da19fcc184b9711e1b4764040d3dc5c07schema%3Dtwitterurl%3Dhttps3A%2F%2Ftwitter.com%2Fdan_abramov%2Fstatus%2F1093497348913803265image%3Dhttps3A%2F%2Fi.embed.ly%2F1%2Fimage3Furl3Dhttps253A252F252Fpbs.twimg.com252Fprofile_images252F906557353549598720252FoapgW_Fp_400x400.jpg26key3Da19fcc184b9711e1b4764040d3dc5c07" target="_blank" rel="noopener">在 Twitter 上</a>直接去问了 Dan Abramov 如何解决这个问题. </p>
<p>React 团队确实会给我们以<a href="https://reactjs.org/docs/hooks-effect.html#explanation-why-effects-run-on-each-update" target="_blank" rel="noopener">警示</a>, 当我们跳过某些副作用的执行的时候.</p>
<h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>在这种情况下, 我们不应该使用 <code>useRef</code>, 而是用 <code>useCallback</code> 来创建一个回调 ref(<a href="https://reactjs.org/docs/refs-and-the-dom.html#callback-refs" target="_blank" rel="noopener">callback ref</a>).</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useHookWithRefCallback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> setRef = useCallback(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ref.current) &#123;</span><br><span class="line">      <span class="comment">// Make sure to cleanup any events/references added to the last instance</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      <span class="comment">// Check if a node is actually passed. Otherwise node would be null.</span></span><br><span class="line">      <span class="comment">// You can now do what you need to, addEventListeners, measure, etc.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save a reference to the node</span></span><br><span class="line">    ref.current = node;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [setRef];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦某个 DOM 节点触发了这个回调函数, 你就能够根据需要消费对应的 DOM 节点.</p>
<blockquote>
<p>这里有个比较完整的示例, 可以观察一下 <a href="https://github.com/thebuilder/react-intersection-observer" target="_blank" rel="noopener">react-intersection-observer</a> 内部所依赖的 <a href="https://github.com/thebuilder/react-intersection-observer/blob/master/src/useInView.tsx" target="_blank" rel="noopener">useInView</a> 的源码</p>
</blockquote>
<h3 id="官方的解决方案"><a href="#官方的解决方案" class="headerlink" title="官方的解决方案"></a>官方的解决方案</h3><p>React 团队在文档的 FAQ 中也有一个<a href="https://reactjs.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node" target="_blank" rel="noopener">相关的例子</a>, 使用 ref callback 来计算 DOM 元素的大小尺寸等. 对于我们所提出的问题, 这也是一个解决方案.</p>
</div></article></div></main><footer><div class="paginator"><a href="/posts/2021/07/06/how-are-function-components-different-from-classes/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 - 2023 <a href="https://icyfish.github.io/posts">Fish</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>