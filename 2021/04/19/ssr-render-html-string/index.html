<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="IDYUPnBNhdnU8o9LRNKZ1RSt14tIxTI0rLeMrBtswXw"><title> React 同构渲染 html 字符串 · Fish</title><meta name="description" content="React 同构渲染 html 字符串 - Fish"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/posts/favicon.png"><link rel="stylesheet" href="/posts/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://icyfish.github.io/posts/atom.xml" title="Fish"><meta name="generator" content="Hexo 7.0.0-rc1"></head><body><div class="wrap"><header><a href="/posts/" class="logo-link"><img src="/posts/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/posts/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/posts/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/posts/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="http://twitter.com/icyfish_" target="_blank" class="nav-list-link">TWITTER</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">React 同构渲染 html 字符串</h1><div class="post-info">Apr 19, 2021</div><div class="post-content"><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>看到这个问题, 大家可能会觉得很诧异, 不是直接用 <code>dangerouslySetInnerHTML</code> 就能实现了吗? 但是实际情况并没有那么简单. </p>
<p>首先介绍我们的技术框架, 项目使用了 <a href="https://github.com/Lucifier129/react-imvc" target="_blank" rel="noopener">react-imvc</a> 实现页面的同构渲染.</p>
<p>针对标题的需求, 我们会实现一个 React 组件, 接受接口下发的 html 字符串(见下, &amp;lt 是因为内容被框架处理过), 渲染出对应的内容.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> codeBlock = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;script</span></span><br><span class="line"><span class="string">  src="https://code.jquery.com/jquery-3.6.0.min.js"&gt;&amp;lt/script&gt;</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">console.log($);</span></span><br><span class="line"><span class="string">&amp;lt/script&gt;</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">console.log(222);</span></span><br><span class="line"><span class="string">&amp;lt/script&gt;</span></span><br><span class="line"><span class="string">&lt;h1&gt;123&lt;/h1&gt;`</span>;</span><br></pre></td></tr></table></figure>
<p>但是在实现的过程中发现一个问题, 由于我们的页面是同构渲染的, React 组件需要同时支持服务端渲染和客户端渲染. </p>
<p>在服务端渲染的场景下, 简单地 <code>dangerouslySetInnerHTML</code> 能够直接满足我们的需求. <strong>但是在客户端渲染的情况下, 我们发现 <code>script</code> 标签中的内容并没有执行</strong>. 那么如何解决这个问题呢?</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><h3 id="分离-html-中-script-标签与其他标签"><a href="#分离-html-中-script-标签与其他标签" class="headerlink" title="分离 html 中 script 标签与其他标签"></a>分离 html 中 script 标签与其他标签</h3><p>JavaScript 代码没有执行的原因是<a href="https://stackoverflow.com/questions/13390588/script-tag-create-with-innerhtml-of-a-div-doesnt-work/13392818#13392818" target="_blank" rel="noopener">规范不允许</a>在 <code>innerHTML</code> 中插入 <code>script</code> 标签, 即使 DOM 元素中可以查看到, 代码的内容也不会执行.</p>
<p>因此我们要在代码中针对 <code>script</code> 标签和其他标签做出分离的处理:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分离出script标签和其他标签内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">separateScript</span>(<span class="params">codeBlock = <span class="string">""</span></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 针对 react-imvc 框架, 需要做这样的处理.</span></span><br><span class="line">  codeBlock = formatScript(codeBlock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> re = <span class="regexp">/&lt;script\b[^&gt;]*&gt;([\s\S]*?)&lt;\/script&gt;/gm</span>;</span><br><span class="line">  <span class="keyword">let</span> match;</span><br><span class="line">  <span class="keyword">let</span> scriptStrList = [];</span><br><span class="line">  <span class="keyword">let</span> contentWithoutScript = codeBlock.replace(re, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ((match = re.exec(codeBlock))) &#123;</span><br><span class="line">    scriptStrList.push(match[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [scriptStrList, contentWithoutScript];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端渲染时 框架的 Script 组件 https://github.com/Lucifier129/react-imvc/blob/master/component/Script.js</span></span><br><span class="line"><span class="comment"> * 把 &lt;/script 转成了 &amp;lt/script, 把它转回来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">formatScript</span>(<span class="params">codeBlock = <span class="string">""</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> scriptRe = <span class="regexp">/&amp;lt\/script/g</span>;</span><br><span class="line">  <span class="keyword">return</span> codeBlock.replace(scriptRe, <span class="string">"&lt;/script"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过处理之后, 我们会得到类似以下形式的 <code>scriptStrList</code> </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scriptStrList = [</span><br><span class="line">  <span class="string">'&lt;script\n  src="https://code.jquery.com/jquery-3.6.0.min.js"&gt;&lt;/script&gt;'</span>,</span><br><span class="line">  <span class="string">"&lt;script&gt;\nconsole.log($);\n&lt;/script&gt;"</span>,</span><br><span class="line">  <span class="string">"&lt;script&gt;\nconsole.log(222);\n&lt;/script&gt;"</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>我们的 React 组件, 会是这样的:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useMemo &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> useAttachScript <span class="keyword">from</span> <span class="string">"../hooks/useAttachScript"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; separateScript &#125; <span class="keyword">from</span> <span class="string">"../utils"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 由于客户端渲染的情况下使用  dangerouslySetInnerHTML 渲染的 script 标签中的代码无法执行</span></span><br><span class="line"><span class="comment"> * 因此需要分离 html 与 script</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">CustomCode</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; codeBlock &#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> [scriptStrList, markup] = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> separateScript(codeBlock);</span><br><span class="line">  &#125;, [codeBlock]);</span><br><span class="line"></span><br><span class="line">  useAttachScript(scriptStrList);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;&#123;</span> <span class="attr">__html:</span> <span class="attr">markup</span> &#125;&#125; <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用: codeBlock 就是问题背景中列出的 codeBlock</span></span><br><span class="line"><span class="comment">// &lt;CustomCode codeBlock=&#123;codeBlock&#125; /&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="手动构造-script-节点"><a href="#手动构造-script-节点" class="headerlink" title="手动构造 script 节点"></a>手动构造 script 节点</h3><p>可以从组件代码中看到这样一个 hook: <code>useAttachScript</code> . 现在我们开始实现这个 hook, 它做的事情是: 处理 <code>scriptStrList</code> 然后用 <code>appendChild</code> 的形式插入我们的 <code>script</code> 标签:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">useAttachScript</span>(<span class="params">scriptStrList = []</span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scriptStrList.length === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    appendScriptList(scriptStrList.join());</span><br><span class="line">  &#125;, [scriptStrList]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> appendScriptList = <span class="function"><span class="params">scriptMarkup</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> scriptHTMLCollection = getScriptHTMLCollection(scriptMarkup);</span><br><span class="line">  <span class="comment">// 获取 div 中的 script 标签列表, scriptHTMLCollection 的类型为 HTMLCollection, 而不是 NodeList</span></span><br><span class="line">  <span class="comment">// 因此实现一个 cloneScript 方法进行转换</span></span><br><span class="line">  <span class="keyword">const</span> scriptNodeList = [...scriptHTMLCollection].map(<span class="function"><span class="params">str</span> =&gt;</span> cloneScript(str)); </span><br><span class="line">	scriptNodeList.forEach(<span class="function"><span class="params">script</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getScriptHTMLCollection = <span class="function"><span class="params">scriptMarkup</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 手动创建一个 div 用以获取 script 标签</span></span><br><span class="line">  <span class="keyword">let</span> divElem = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">  divElem.innerHTML = scriptMarkup;</span><br><span class="line">  <span class="keyword">return</span> divElem.getElementsByTagName(<span class="string">"script"</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cloneScript = <span class="function"><span class="params">sourceScript</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Array</span>.from(sourceScript.attributes).forEach(<span class="function"><span class="params">attr</span> =&gt;</span> &#123;</span><br><span class="line">    script.setAttribute(attr.name, attr.value);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  script.innerHTML = sourceScript.innerHTML;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> script;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上的代码看似已经没有大问题了, 但是对于最开始的 html 字符串示例, 我们发现了一个问题: 有可能抛出 <code>$ is not defined</code> 的错误, 虽然是代码本身的问题, 但我们还是希望再做出一些优化.</p>
<h3 id="确保各个标签按照先后顺序执行"><a href="#确保各个标签按照先后顺序执行" class="headerlink" title="确保各个标签按照先后顺序执行"></a>确保各个标签按照先后顺序执行</h3><p>由于我们的业务场景限制, 接口下发的 html 内容可能是运营人员或者产品经理所编写的. 所以我们在实现时要尽可能地避免代码出错, 在程序层面确保各个标签按照先后顺序执行.</p>
<p><code>useAttachScript</code> 是在组件渲染完之后执行的, 因此不必担心我们的处理影响页面主要部分的渲染.</p>
<p>那么开始优化 <code>useAttachScript</code> :</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">useAttachScript</span>(<span class="params">scriptStrList = []</span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scriptStrList.length === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    appendScriptList(scriptStrList.join());</span><br><span class="line">  &#125;, [scriptStrList]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> appendScriptList = <span class="keyword">async</span> scriptMarkup =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> scriptHTMLCollection = getScriptHTMLCollection(scriptMarkup);</span><br><span class="line">  <span class="comment">// 获取 div 中的 script 标签列表, scriptHTMLCollection 的类型为 HTMLCollection, 而不是 NodeList</span></span><br><span class="line">  <span class="comment">// 因此实现一个 cloneScript 方法进行转换</span></span><br><span class="line">  <span class="keyword">const</span> scriptNodeList = [...scriptHTMLCollection].map(<span class="function"><span class="params">str</span> =&gt;</span> cloneScript(str));</span><br><span class="line">  <span class="comment">// 将 forEach 改造成 for of, 因为 forEach 中不支持 async/await</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> scriptElem <span class="keyword">of</span> scriptNodeList) &#123;</span><br><span class="line">    <span class="keyword">await</span> appendScript(scriptElem);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> appendScript = <span class="function"><span class="params">scriptElem</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; attributes = &#123;&#125; &#125; = scriptElem;</span><br><span class="line">    <span class="keyword">let</span> &#123; src &#125; = attributes;</span><br><span class="line">    <span class="keyword">if</span> (src) &#123;</span><br><span class="line">      <span class="comment">// 如果有需要加载的外部脚本, 等加载完成之后再插入下一个脚本</span></span><br><span class="line">      scriptElem.onload = resolve;</span><br><span class="line">      scriptElem.onerror = reject;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 否则直接插入</span></span><br><span class="line">      resolve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.head.appendChild(scriptElem);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getScriptHTMLCollection = <span class="function"><span class="params">scriptMarkup</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 手动创建一个 div 用以获取 script 标签</span></span><br><span class="line">  <span class="keyword">let</span> divElem = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">  divElem.innerHTML = scriptMarkup;</span><br><span class="line">  <span class="keyword">return</span> divElem.getElementsByTagName(<span class="string">"script"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cloneScript = <span class="function"><span class="params">sourceScript</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Array</span>.from(sourceScript.attributes).forEach(<span class="function"><span class="params">attr</span> =&gt;</span> &#123;</span><br><span class="line">    script.setAttribute(attr.name, attr.value);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  script.innerHTML = sourceScript.innerHTML;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> script;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>至此, 我们的 React 组件就能够同时支持服务端和客户端渲染了.</p>
<p>最终代码示例: <a href="https://github.com/icyfish/react-app/blob/master/src/components/CustomCode.js" target="_blank" rel="noopener">Github Repo</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://stackoverflow.com/questions/13390588/script-tag-create-with-innerhtml-of-a-div-doesnt-work/13392818#13392818" target="_blank" rel="noopener">script tag create with innerHTML of a div doesn’t work</a></li>
<li><a href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/" target="_blank" rel="noopener">ES6 In Depth: Iterators and the for-of loop</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/posts/2021/04/19/usedelegate-hook/" class="prev">PREV</a><a href="/posts/2020/12/25/build-your-own-react/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 - 2023 <a href="https://icyfish.github.io/posts">Fish</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>