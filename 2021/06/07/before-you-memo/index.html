<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="IDYUPnBNhdnU8o9LRNKZ1RSt14tIxTI0rLeMrBtswXw"><title> 在使用 memo 之前 · Fish</title><meta name="description" content="在使用 memo 之前 - Fish"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/posts/favicon.png"><link rel="stylesheet" href="/posts/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://icyfish.github.io/posts/atom.xml" title="Fish"><meta name="generator" content="Hexo 7.0.0-rc1"></head><body><div class="wrap"><header><a href="/posts/" class="logo-link"><img src="/posts/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/posts/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/posts/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/posts/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="http://twitter.com/icyfish_" target="_blank" class="nav-list-link">TWITTER</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">在使用 memo 之前</h1><div class="post-info">Jun 7, 2021</div><div class="post-content"><p>原文: <a href="https://overreacted.io/before-you-memo/" target="_blank" rel="noopener">Before You memo()</a></p>
<p>关于 React 性能优化的话题, 很多文章都有所涉及. 大部分文章针对 state 更新卡顿的问题, 给出的方案大都是这样的:</p>
<ol>
<li>首先确认代码是否是在生产环境运行. (开发环境的代码大都会比较慢, 在一些极端情况下, 程度更甚.)</li>
<li>确认 state 的位置, 是否被置于组件树中过于高的位置. (比如说, 将用户输入的状态放在一个集中管理的 store 中, 就不太合适)</li>
<li>使用 React 开发者工具检测组件重新渲染的次数, 将开销比较大的组件用 <code>memo()</code> 进行包裹. (同时组件内部的变量可以用 <code>useMemo()</code> 缓存下来.)</li>
</ol>
<p>最后一步比较繁琐, 特别是对于处于组件树中间位置的组件, 理想情况下, 可以使用编译器帮助我们完成这一步的工作. 可能在不久的将来就能实现了.</p>
<p><strong>在本文后续的内容中, 我想分享两种与上面所说的不同的方式.</strong> 了解之后你会发现这两种方式其实特别地基础, 也因此很多人甚至忽略了它们对渲染性能优化的效果.</p>
<p><strong>这些方式对比你已经了解的优化技巧, 是互补的内容.</strong> 它们并不是 <code>memo</code> 和 <code>useMemo</code> 的替代品, 但是在优化过程中首先尝试这些方式, 是比较可取的.</p>
<h2 id="构造出一个渲染性能比较差的组件"><a href="#构造出一个渲染性能比较差的组件" class="headerlink" title="构造出一个渲染性能比较差的组件"></a>构造出一个渲染性能比较差的组件</h2><p>下面的示例代码, 是一个有严重性能问题的组件:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [color, setColor] = useState(<span class="string">'red'</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input value=&#123;color&#125; onChange=&#123;(e) =&gt; setColor(e.target.value)&#125; /&gt;</span><br><span class="line">      &lt;p style=&#123;&#123; color &#125;&#125;&gt;Hello, world!&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ExpensiveTree /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function ExpensiveTree() &#123;</span></span><br><span class="line"><span class="regexp">  let now = performance.now();</span></span><br><span class="line"><span class="regexp">  while (performance.now() - now &lt; 100) &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 手动构造出延迟的效果, 100ms 之内不做任何事</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  return &lt;p&gt;I am a very slow component tree.&lt;/</span>p&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://codesandbox.io/s/frosty-glade-m33km?file=/src/App.js" target="_blank" rel="noopener">CodeSandBox 代码示例</a></p>
<p>以上代码的问题是, 无论何时 <code>App</code> 中的 <code>color</code> 变化了, 都会进行重新渲染我们手动构造出的存在延迟效果的组件: <code>&lt;ExpensiveTree/&gt;</code>. </p>
<p>我可以简单地将用 <code>memo()</code> 对这个组件进行包裹, 然后结束我们的优化, 但是这一类优化技巧, 很多其他文章都已经讲得很详细了, 因此我们不会过多着墨于此. 接下来我想介绍的是另外两种优化方式. </p>
<h2 id="解决方案-1-将-State-移动到内部"><a href="#解决方案-1-将-State-移动到内部" class="headerlink" title="解决方案 1 - 将 State 移动到内部"></a>解决方案 1 - 将 State 移动到内部</h2><p>仔细观察渲染的代码, 会发现其实只有高亮的部分关注 <code>color</code> 的值:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// highlight-next-line</span></span><br><span class="line">  <span class="keyword">let</span> [color, setColor] = useState(<span class="string">'red'</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">		<span class="comment">// highlight-start</span></span><br><span class="line">      &lt;input value=&#123;color&#125; onChange=&#123;(e) =&gt; setColor(e.target.value)&#125; /&gt;</span><br><span class="line">      &lt;p style=&#123;&#123; color &#125;&#125;&gt;Hello, world!&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">		/</span><span class="regexp">/ highlight-end</span></span><br><span class="line"><span class="regexp">      &lt;ExpensiveTree /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们将这部分抽象成 <code>Form</code> 组件, 然后再把状态移到 <code>From</code> 中:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">			<span class="comment">// highlight-next-line</span></span><br><span class="line">      &lt;Form /&gt;</span><br><span class="line">      &lt;ExpensiveTree /&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Form() &#123;</span></span><br><span class="line"><span class="regexp">	/</span><span class="regexp">/ highlight-next-line</span></span><br><span class="line"><span class="regexp">  let [color, setColor] = useState('red');</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;&gt;</span></span><br><span class="line"><span class="regexp">			/</span><span class="regexp">/ highlight-start</span></span><br><span class="line"><span class="regexp">      &lt;input value=&#123;color&#125; onChange=&#123;(e) =&gt; setColor(e.target.value)&#125; /</span>&gt;</span><br><span class="line">      &lt;p style=&#123;&#123; color &#125;&#125;&gt;Hello, world!&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">			/</span><span class="regexp">/ highlight-end</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://codesandbox.io/s/billowing-wood-1tq2u?file=/src/App.js" target="_blank" rel="noopener">CodeSandBox 代码示例</a></p>
<p>经过改造之后, 当 <code>color</code> 变化, 只有 <code>Form</code> 会重新渲染. 问题解决了.</p>
<h2 id="解决方案-2-将内容移动到外部"><a href="#解决方案-2-将内容移动到外部" class="headerlink" title="解决方案 2 - 将内容移动到外部"></a>解决方案 2 - 将内容移动到外部</h2><p>如果 state 在 <code>ExpensiveTree</code> 外部被消费, 然后将 <code>color</code> 属性设置到父级 <code>&lt;div&gt;</code> 上, 就无法使用以上的优化方式了:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// highlight-next-line</span></span><br><span class="line">  <span class="keyword">let</span> [color, setColor] = useState(<span class="string">'red'</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">	<span class="comment">// highlight-next-line</span></span><br><span class="line">    &lt;div style=&#123;&#123; color &#125;&#125;&gt;</span><br><span class="line">      &lt;input value=&#123;color&#125; onChange=&#123;(e) =&gt; setColor(e.target.value)&#125; /&gt;</span><br><span class="line">      &lt;p&gt;Hello, world!&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ExpensiveTree /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><a href="https://codesandbox.io/s/bold-dust-0jbg7?file=/src/App.js" target="_blank" rel="noopener">CodeSandBox 代码示例</a></p>
<p>由于父组件也用到了 <code>color</code> 属性, 我们不能够像先前那样将消费了 <code>color</code> 属性的组件额外抽象出来. 那这样的话, 就只能使用 <code>memo</code> 进行优化了吗?</p>
<p>其实还有另一种简单的方式:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ColorPicker&gt;</span><br><span class="line">		<span class="comment">// highlight-start</span></span><br><span class="line">      &lt;p&gt;Hello, world!&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ExpensiveTree /</span>&gt;</span><br><span class="line">		<span class="comment">// highlight-end</span></span><br><span class="line">    &lt;<span class="regexp">/ColorPicker&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ highlight-next-line</span></span><br><span class="line"><span class="regexp">function ColorPicker(&#123; children &#125;) &#123;</span></span><br><span class="line"><span class="regexp">  let [color, setColor] = useState("red");</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div style=&#123;&#123; color &#125;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;input value=&#123;color&#125; onChange=&#123;(e) =&gt; setColor(e.target.value)&#125; /</span>&gt;</span><br><span class="line"><span class="comment">// highlight-next-line</span></span><br><span class="line">			&#123;children&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><a href="https://codesandbox.io/s/wonderful-banach-tyfr1?file=/src/App.js:58-423" target="_blank" rel="noopener">CodeSandBox 代码示例</a></p>
<p>将 <code>App</code> 组件拆分成两部分, 把 <code>color</code> 属性相关的逻辑都移到 <code>ColorPicker</code> 中.</p>
<p>这样抽象出来之后, <code>color</code> 相关的部分依然存在于 <code>App</code> 中, 不消费 <code>color</code> 的部分作为 <code>children</code> 被传入了 <code>ColorPicker</code> 中.  </p>
<p>当 <code>color</code> 属性变化的时候, <code>ColorPicker</code> 会重新渲染. 但是由于它接受到的 <code>children</code> 属性和前一次渲染没有差别, 因此 <code>children</code> 的内容不会重新渲染.</p>
<p>这样一来, <code>&lt;ExpensiveTree/&gt;</code> 就不会重新渲染.</p>
<h2 id="我想要表达什么"><a href="#我想要表达什么" class="headerlink" title="我想要表达什么"></a>我想要表达什么</h2><p>在使用 <code>memo</code> 或者 <code>useMemo</code> 对组件进行优化的时候, 或许可以先重新审视一下我们的代码, 将经常会变化的部分, 和比较不经常变化的部分进行拆分.</p>
<p>比较有意思的一点是, 这样拆分的最终目的<strong>其实并不是为了性能优化考虑.</strong> 使用 <code>children</code> 属性分离组件, 能够使得我们应用的数据流更加简洁, 同时减少传入组件的 props. 在这类场景下, 提升性能其实是意外的收获.</p>
<p>更惊喜的是, 这样的模式在未来能够带来更大的性能收益.</p>
<p>举个例子, 当 <a href="https://reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html" target="_blank" rel="noopener">Sever Components</a> 成为 React 的稳定特性之后, 读取 <code>children</code> 属性的工作就能够在<a href="https://www.youtube.com/watch?v=TQQPAU21ZUw&amp;t=1314s" target="_blank" rel="noopener">在服务端进行</a>. <code>&lt;ExpensiveTree /&gt;</code> 也能够在服务端执行, 这样一来, 即使在此层级之上的 state 更新, 在客户端也不会引起 <code>&lt;ExpensiveTree /&gt;</code> 那部分代码的执行.</p>
<p>这是 <code>memo</code> 没办法帮我们做到的. 但是重申一次, 我所说的这两种方法需要配合 <code>memo</code> 和 <code>useMemo</code> 使用, 一定不要忘了移动状态 (state) 和内容.</p>
<p>同时记得, 打开 React 开发者工具观察 memo 的优化效果.</p>
<h2 id="类似的文章"><a href="#类似的文章" class="headerlink" title="类似的文章"></a>类似的文章</h2><p>看完全文之后, 读者可能会觉得, 以前好像看到过类似的文章? <a href="https://kentcdodds.com/blog/optimize-react-re-renders" target="_blank" rel="noopener">确实是的</a>.</p>
<p>这并不是一个全新的概念. 是 React 作为组合模型所演变出的合理优化结果. 或许是因为方式太过简单, 被很多人忽略了, 但是其实这是个值得被重视的方法.</p>
</div></article></div></main><footer><div class="paginator"><a href="/posts/2021/07/02/a-complete-guide-to-useeffect/" class="prev">PREV</a><a href="/posts/2021/04/19/usedelegate-hook/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 - 2023 <a href="https://icyfish.github.io/posts">Fish</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>