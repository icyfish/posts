<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="IDYUPnBNhdnU8o9LRNKZ1RSt14tIxTI0rLeMrBtswXw"><title> Why webpack · Fish</title><meta name="description" content="Why webpack - Fish"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/posts/favicon.png"><link rel="stylesheet" href="/posts/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://icyfish.github.io/posts/atom.xml" title="Fish"><meta name="generator" content="Hexo 7.0.0-rc1"></head><body><div class="wrap"><header><a href="/posts/" class="logo-link"><img src="/posts/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/posts/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/posts/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/posts/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="http://twitter.com/icyfish_" target="_blank" class="nav-list-link">TWITTER</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Why webpack</h1><div class="post-info">May 15, 2017</div><div class="post-content"><p>介绍了webpack产生的最主要原因.</p>
<a id="more"></a>
<h2 id="服务器端模板与单页面应用"><a href="#服务器端模板与单页面应用" class="headerlink" title="服务器端模板与单页面应用"></a>服务器端模板与单页面应用</h2><p><strong>服务器端模板Server Side Templating(利用服务器端渲染server side rendering)</strong></p>
<p>后端服务器创建HTML文件, 将其发送给用户, 这个HTML文件是fully-rendered HTML document(组成一个完整页面所有需要的内容都在这个文件中, 包括图片, css文件, js文件等). 依赖服务器整合所有内容到HTML文件中.</p>
<p><img src="/posts/images/sst.jpg" alt="server-side-templating"></p>
<p>在浏览器中输入网址之后, 向服务器发送HTTP请求, 服务器发送HTML文件到客户端, 用户浏览HTML网页时如果点击了某个链接, 浏览器又会向服务器发送HTTP请求, 然后接受到新的HTML文件. 使用服务器端渲染, 每一次HTTP请求都会收到一个包含所有内容新的HTML文件.</p>
<p><strong>单页面应用Single Page App(利用客户端渲染clien side rendering)</strong> </p>
<p>服务器只发送HTML文件的一个模板给用户, 所有需要的内容由JavaScript在客户端负责整合并渲染以创建一个完整的应用. 依赖JavaScript文件整合所有内容.</p>
<p><img src="/posts/images/spa.jpg" alt="single-page-app"></p>
<p>用户请求页面, 浏览器向服务器发出HTTP请求, 服务器向客户端发送包含了js文件的HTML文件, 然后前端框架React/Vue/Angular等就会开始发挥作用整合一些HTML页面展示给用户. 当用户点击某个链接时, 比如转换到另一个页面, 这时并不会向服务器发送HTTP请求, 请求HTML文件, 而是由前端框架负责渲染新的内容到页面. </p>
<p><strong>两者JavaScript代码量的对比</strong></p>
<p><img src="/posts/images/js-code-amount.jpg" alt="js-code-amount"></p>
<h2 id="JS代码量大所带来的问题"><a href="#JS代码量大所带来的问题" class="headerlink" title="JS代码量大所带来的问题"></a>JS代码量大所带来的问题</h2><p>假设有个比较大的项目, 所有的JS代码都在以下三个文件中, 每个文件的代码有几千多行. </p>
<p><img src="/posts/images/three-js-files.jpg" alt="three-js-files"></p>
<p>假如我们现在需要对项目的header进行修改, 改变导航栏的一部分功能, 在几千多行代码中找出负责这部分的代码并执行修改十分不容易. 为了解决这个问题, 引入了module(模块)的概念, 将巨大的JS文件分成多个负责页面不同部分的模块文件. 这样, 修改某部分的功能就变得更容易.</p>
<p><img src="/posts/images/modules.jpg" alt="modules"></p>
<p>然而, 分成多个模块也会带来一些问题.</p>
<p><strong>1.加载顺序</strong></p>
<p>不同的JS文件之间有依赖, 因此加载顺序是个比较重要的问题. 我们需要确保应用的每一次执行, 模块的加载顺序都正确且一致. </p>
<p><img src="/posts/images/load-order.jpg" alt="load-order"></p>
<h3 id="webpack如何确保各个模块的执行顺序"><a href="#webpack如何确保各个模块的执行顺序" class="headerlink" title="webpack如何确保各个模块的执行顺序"></a>webpack如何确保各个模块的执行顺序</h3><p>现在有两个文件<code>sum.js</code>以及<code>index.js</code></p>
<p><code>sum.js</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> sum;</span><br></pre></td></tr></table></figure>
<p><code>index.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">'./sum'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./image_viewer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> total = sum(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(total);</span><br></pre></td></tr></table></figure>
<p>如果使用webpack将两者整合, 具体过程不再详述, 分析生成的<code>bundle.js</code>文件, 可以发现webpack的工作原理, 以下是进行简化之后的bundle文件, 可以清楚地了解webpack是如何确保执行顺序的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myModules = [</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> sum = myModules[<span class="number">0</span>]();</span><br><span class="line">    <span class="keyword">const</span> total = sum(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(total);</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> entryPointIndex = <span class="number">1</span>;</span><br><span class="line">myModules[entryPointIndex]();</span><br></pre></td></tr></table></figure>
<p><strong>2.性能损耗</strong></p>
<p>使用HTTP请求多个JS文件对性能损耗较大, JS文件越多, 加载所花去的时间就越长, 在移动设备上这个问题更甚. </p>
<h2 id="webpack最主要功能"><a href="#webpack最主要功能" class="headerlink" title="webpack最主要功能"></a>webpack最主要功能</h2><p>webpack的存在, 解决了上面提到的问题:</p>
<p><img src="/posts/images/webpack1.jpg" alt="webpack1"></p>
<p>webpack的最主要功能就是将多个模块的JS文件打包成一个文件: bundle.js 并且确保每一个模块文件的执行顺序正确. </p>
<hr>
<p><strong>参考</strong></p>
<ul>
<li><a href="https://www.udemy.com/webpack-2-the-complete-developers-guide/learn" target="_blank" rel="noopener">webpack 2: The Complete Developer’s Guide</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/posts/2017/05/18/babel-preset-env/" class="prev">PREV</a><a href="/posts/2017/05/13/webpack2-basics/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 - 2023 <a href="https://icyfish.github.io/posts">Fish</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>