<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="IDYUPnBNhdnU8o9LRNKZ1RSt14tIxTI0rLeMrBtswXw"><title> React 如何区分类组件和函数式组件? · Fish</title><meta name="description" content="React 如何区分类组件和函数式组件? - Fish"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/posts/favicon.png"><link rel="stylesheet" href="/posts/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://icyfish.github.io/posts/atom.xml" title="Fish"><meta name="generator" content="Hexo 7.0.0-rc1"></head><body><div class="wrap"><header><a href="/posts/" class="logo-link"><img src="/posts/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/posts/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/posts/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/posts/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="http://twitter.com/icyfish_" target="_blank" class="nav-list-link">TWITTER</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">React 如何区分类组件和函数式组件?</h1><div class="post-info">Jan 15, 2020</div><div class="post-content"><p>原文: <a href="https://overreacted.io/how-does-react-tell-a-class-from-a-function/" target="_blank" rel="noopener">How Does React Tell a Class from a Function?</a></p>
<p>下面这个 <code>Greeting</code> 是一个函数式 React 组件:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React 同样支持以类的形式定义一个组件:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(函数式组件可以通过 <a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">hooks</a> 保存状态)</p>
<p>不过当我们使用一个组件的时候, 我们并不在意它是如何定义的:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class or function — whatever.</span></span><br><span class="line">&lt;Greeting /&gt;</span><br></pre></td></tr></table></figure>
<p>不过 React 本身对组件是函数式还是类式, 十分在意.</p>
<p>如果 <code>Greeting</code> 是函数式组件, React 的使用方式就是调用它:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Your code</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inside React</span></span><br><span class="line"><span class="keyword">const</span> result = Greeting(props); <span class="comment">// &lt;p&gt;Hello&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果 <code>Greeting</code> 是类式组件, React 的使用方式就是使用 <code>new</code> 操作符来实例化这个组件, 并调用所创建实例的 <code>render</code> 方法.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Your code</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inside React</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Greeting(props); <span class="comment">// Greeting &#123;&#125;</span></span><br><span class="line"><span class="keyword">const</span> result = instance.render(); <span class="comment">// &lt;p&gt;Hello&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上两种情况下, React 的目标都是获取需要被渲染的 DOM 节点(在我们的例子中是 <code>&lt;p&gt;Hello&lt;/p&gt;</code> ). 具体的获取步骤, 还是根据 <code>Greeting</code> 如何被定义来决定.</p>
<p><strong>那么 React 是如何知道组件是类还是函数的呢?</strong></p>
<p>就像我在<a href="https://overreacted.io/why-do-we-write-super-props/" target="_blank" rel="noopener">这篇文章</a>中说的, 即使不知道这点, <strong>你也能够高效地用 React 构建出 web 应用.</strong> 我也并不是一开始就了解这个知识的, 因此请不要将这个知识点作为面试题询问求职者. 实际上, 这篇文章所涉及的知识更偏向于 JavaScript 而不是 React.</p>
<p>这篇文章的目标读者是对 React 的底层原理有好奇心的开发者, 如果你是的话, 那么就让我们一起探索吧.</p>
<p><strong>我们的探索旅程会很长. 请系好安全带. 本文涉及到的 React 知识点其实并不多, 更多的是关于 JavaScript 的知识点, 比如说: <code>new</code> , <code>this</code> , <code>class</code> , 箭头函数, <code>prototype</code> , <code>__proto__</code>, <code>instanceof</code> 等. 幸运的是, 当你在使用 React 的时候, 并不需要特别考虑这些. 不过站在 React 的开发者角度, 情况就不一样了……</strong></p>
<p>(如果你不希望了解实现细节, 只想要知道答案, 请直接查看文末的内容.)</p>
<hr>
<p>首先我们需要理解, 为什么区别对待函数式组件和类组件是重要的. 当我们调用类组件时候, 需要依赖 <code>new</code> 操作符:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 Greeting 是函数式组件, 在react内部会被这样调用</span></span><br><span class="line"><span class="keyword">const</span> result = Greeting(props); <span class="comment">// &lt;p&gt;Hello&lt;/p&gt;</span></span><br><span class="line"><span class="comment">// 如果 Greeting 是 class 组件, 在react内部会被这样调用</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Greeting(props); <span class="comment">// Greeting &#123;&#125;</span></span><br><span class="line"><span class="keyword">const</span> result = instance.render(); <span class="comment">// &lt;p&gt;Hello&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在我们重点关注一下, <code>new</code> 操作符在 JavaScript 中具体做了些什么.</p>
<hr>
<p>过去 JavaScript 中没有类的概念. 但是我们可以构造一个与类有类似功能的函数. 具体见下面的例子, 针对这种特殊的函数, 我们使用 <code>new</code>关键字进行调用.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只是一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fred = <span class="keyword">new</span> Person(<span class="string">'Fred'</span>); <span class="comment">// ✅ Person &#123;name: 'Fred'&#125;</span></span><br><span class="line"><span class="keyword">var</span> george = Person(<span class="string">'George'</span>); <span class="comment">// 🔴 不会起作用, </span></span><br><span class="line"><span class="comment">// 如果将代码在控制台执行, 会发现 this 指向全局 window.name 是 George</span></span><br></pre></td></tr></table></figure>
<p>如果我们调用 <code>Person(&#39;Fred&#39;)</code> 时没有加上 <code>new</code> 关键字, 函数中的 <code>this</code> 会指向全局, 那么这个 <code>this</code> 就一点意义也没有了. 我们的代码会崩溃, 同时还做了件蠢事: 创建了一个无用的全局变量.</p>
<p><strong>那么使用 <code>new</code> 调用函数时具体发生了些什么呢?</strong></p>
<p>在调用函数时添加<code>new</code>, 相当于告诉 JavaScript, <code>Person</code>虽然只是个函数, 但是我们可以把它看做类构造器. <strong>此时 JavaScript 就会创建一个<code>{}</code>对象, 然后<code>Person</code>中的<code>this</code>值指向该对象, 同时将 <code>name</code> 设置为该对象的属性, 并且 <code>return</code> 出该对象.</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fred = <span class="keyword">new</span> Person(<span class="string">'Fred'</span>); <span class="comment">// Same object as `this` inside `Person`</span></span><br></pre></td></tr></table></figure>
<p>通过以上的 <code>new</code> 调用, 对象 <code>fred</code> 还可以读取构造器函数 <code>Person.prototype</code> 上的属性.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hi, I am '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fred = <span class="keyword">new</span> Person(<span class="string">'Fred'</span>);</span><br><span class="line">fred.sayHi();</span><br></pre></td></tr></table></figure>
<p>在 JavaScript 不原生支持<code>class</code>之前, 开发者就是通过这种方式模拟类的.</p>
<hr>
<p><code>new</code> 关键字存在已久, 而 <code>class</code> 的支持却是近段时间的事. 现在我们使用<code>class</code>改写先前的代码.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    alert(<span class="string">'Hi, I am '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fred = <span class="keyword">new</span> Person(<span class="string">'Fred'</span>);</span><br><span class="line">fred.sayHi();</span><br></pre></td></tr></table></figure>
<p>在设计编程语言和 API 时, 用户的痛点至关重要.</p>
<p>开发者在编写函数时, JavaScript 无法猜测到函数是需要被直接调用还是在之前加关键词 <code>new</code> 调用.  因此开发者在调用类似 <code>Person</code> 这样的构造函数时, 务必记得在前面添加 <code>new</code> 关键字, 否则就会给程序引入一些令人疑惑的问题.</p>
<p><strong>有了 Class 语法之后, 我们的语境中就有了类的概念, 对于这类特殊的函数, 我们就能说, 它不仅仅是一个函数, 而是一个类, 同时有自己的构造函数.</strong> 如果你在调用它的时候忘了加上 <code>new</code> 关键字, JavaScript 就会抛出错误.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fred = <span class="keyword">new</span> Person(<span class="string">'Fred'</span>);</span><br><span class="line"><span class="comment">// ✅  If Person is a function: works fine</span></span><br><span class="line"><span class="comment">// ✅  If Person is a class: works fine too</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> george = Person(<span class="string">'George'</span>); <span class="comment">// We forgot `new`</span></span><br><span class="line"><span class="comment">// 😳 If Person is a constructor-like function: confusing behavior</span></span><br><span class="line"><span class="comment">// 🔴 If Person is a class: fails immediately</span></span><br></pre></td></tr></table></figure>
<p>这样一来, 我们就避免写出造成许多隐藏bug的代码, 比如 <code>this.name</code> 被当作是 <code>window.name</code> 而不是我们所预期的 <code>george.name</code> .</p>
<p>不过如果 React 也必须遵循这个原则的话, 那么在调用任何类组件的时候, 就必须在之前加上 <code>new</code> 关键字, 否则的话 JavaScript 就会抛出异常.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">	render() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 🔴 React 无法这样做</span></span><br><span class="line"><span class="keyword">const</span> instance = Counter(props);</span><br></pre></td></tr></table></figure>
<hr>
<p>那么 React 是如何解决这个问题的呢? 大多数开发者在使用React时会同时使用<code>Babel</code> 来编译最新语法的代码以兼容旧版本的浏览器. 因此我们把解决方案的头绪放在了编译器上.</p>
<p>在前几个版本的 <code>Babel</code> 中, 类可以不需要声明 <code>new</code> 关键字直接调用, 但是这个问题很快被 <code>Babel</code> 团队修复了, 我们来看一下他们的修复方式:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// A bit simplified from Babel output:</span></span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Person)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot call a class as a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Our code:</span></span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Person(<span class="string">'Fred'</span>); <span class="comment">// ✅ Okay</span></span><br><span class="line">Person(<span class="string">'George'</span>);   <span class="comment">// 🔴 Cannot call a class as a function</span></span><br></pre></td></tr></table></figure>
<p>如果你看过项目打包之后的代码的话, 可能会觉得这个函数似曾相识, 这个就是<code>_classCallCheck</code> 函数所做的事情. (你可以通过开启”宽松检查模式”来减少打包之后代码的量, 但是这当然也带来了一个问题: 当处理真正的原生类语法时, 情况会变得更加复杂. You can reduce the bundle size by opting into the “loose mode” with no checks but this might complicate your eventual transition to real native classes.)</p>
<hr>
<p>至此, 我们明白了调用函数时加 <code>new</code> 与不加 <code>new</code> 的区别:</p>
<p><img src="/posts/images/compare.png" alt="compare"></p>
<p>这就是为什么, 在React中, 正确调用组件是多么重要. <strong>如果组件被定义为类组件, React必须在前添加 <code>new</code> 关键字进行调用.</strong></p>
<p>那么 React 是否可以不依赖任何其他信息区分出组件是函数式组件还是class组件呢?</p>
<p>并不简单. 虽然我们<a href="https://stackoverflow.com/questions/29093396/how-do-you-check-the-difference-between-an-ecmascript-6-class-and-function" target="_blank" rel="noopener">在 JavaScript 中可以区分出 class 函数和普通函数</a>, 但是被 <code>Babel</code> 处理过的代码, 就很难区分了. 因为经过处理之后, 对于浏览器来说, 它们都是普通的函数. 不过在 React 中, 我们还是有办法处理的.</p>
<hr>
<p>或许 React 可以针对每一次调用都加上 <code>new</code> 关键字? 遗憾的事, 这样的方式并不靠谱. </p>
<p>调用普通函数时添加 <code>new</code> 关键字会为该函数创建一个对象实例. 针对构造器函数, 使用 <code>new</code> 调用是预期行为, 但是针对函数式组件, 这种调用方式就会让人觉得疑惑.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// We wouldn’t expect `this` to be any kind of instance here</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这个原因并没有到不能接受的程度, 但是还有其他两个重要原因决定了不可以始终添加 <code>new</code> 关键词进行函数调用.</p>
<hr>
<p>第一个原因是使用 <code>new</code> 调用箭头函数(未被 Babel 编译过) 会抛出异常:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Greeting = <span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">new</span> Greeting(); <span class="comment">// 🔴 Greeting is not a constructor</span></span><br></pre></td></tr></table></figure>
<p>由于不符合箭头函数的设计语法, JavaScript 有意限制了这种行为. 箭头函数最主要的特点之一是没有自己的 <code>this</code> , 如果在箭头函数内部使用 <code>this</code> 的话, <code>this</code> 的值会由离它最近的普通函数决定.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Friends</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> friends = <span class="keyword">this</span>.props.friends;</span><br><span class="line">    <span class="keyword">return</span> friends.map(<span class="function"><span class="params">friend</span> =&gt;</span></span><br><span class="line">      &lt;Friend</span><br><span class="line">        <span class="comment">// `this` is resolved from the `render` method</span></span><br><span class="line">        size=&#123;<span class="keyword">this</span>.props.size&#125;</span><br><span class="line">        name=&#123;friend.name&#125;</span><br><span class="line">        key=&#123;friend.id&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>箭头函数没有自己的 <code>this</code>. 因此我们没有办法将箭头函数改造为构造器函数.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 🔴 This wouldn’t make sense!</span></span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>JavaScript</strong> 禁止了使用 <code>new</code> 调用箭头函数的行为. 也是由于同样的原因, 我们必须使用 <code>new</code> 关键词实例化一个类. </p>
<p>因此, 在React中用 <code>new</code> 调用函数是不合理的. 那么针对这种情况, 我们是否可以检测出函数是否为箭头函数(如果没有 <code>prototype</code> , 则非箭头函数), 然后针对它做些特殊处理 (不要用 <code>new</code> 去调用它).</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;).prototype; <span class="comment">// undefined</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;).prototype <span class="comment">// &#123;constructor: f&#125;</span></span><br></pre></td></tr></table></figure>
<p>但是函数经过Babel编译之后, 就<a href="https://github.com/facebook/react/issues/4599#issuecomment-136562930" target="_blank" rel="noopener">不能够用以上的方式判断</a>了. 编译之后的结果:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;).prototype;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;).prototype;</span><br></pre></td></tr></table></figure>
<p>不过这个问题比较好解决, 影响比较严重的是另一个原因:</p>
<hr>
<p>当函数的返回值是字符串或其他原始类型时, 使用 <code>new</code> 对其进行调用不会得到我们预期的结果.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Hello'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Greeting(); <span class="comment">// ✅ 'Hello'</span></span><br><span class="line"><span class="keyword">new</span> Greeting(); <span class="comment">// 😳 Greeting &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>这个行为和 <code>new</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener">操作符</a>本身的设计有关. 在前文中我们知道, <code>new</code> 会告诉 JavaScript 引擎创建一个对象,  <code>this</code> 指向所创建的对象实例, 然后 <code>return</code> 出该实例.</p>
<p>JavaScript  同样允许函数被 <code>new</code> 调用时, 通过控制 <code>return</code> 的值来覆盖默认返回的对象.  当在对象池模式下, 想要复用函数实例时, 这种模式就可以发挥作用了. </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created lazily</span></span><br><span class="line"><span class="keyword">var</span> zeroVector = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vector</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x === <span class="number">0</span> &amp;&amp; y === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (zeroVector !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Reuse the same instance</span></span><br><span class="line">      <span class="keyword">return</span> zeroVector;</span><br><span class="line">    &#125;</span><br><span class="line">    zeroVector = <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 😲 b === c</span></span><br></pre></td></tr></table></figure>
<p>不过有一点需要注意的是, 当手动 <code>return</code> 出的不是对象, 而是字符串或者数字类型, 这些值就无法覆盖默认的对象.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Answer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Answer(); <span class="comment">// ✅ 42</span></span><br><span class="line"><span class="keyword">new</span> Answer(); <span class="comment">// 😳 Answer &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>因此, 如果始终用 <code>new</code> 调用函数, <code>React</code> 就永远无法支持返回值为数字或者字符串的组件了.</p>
<p>由于这个原因, 我们必须做出一些妥协.</p>
<hr>
<p>至此我们学到了: React 针对类组件调用时(包括经过 Babel 处理的结果), 需要添加 <code>new</code> 关键字, 但是普通函数和箭头函数调用却不需要. 可是到目前为止并没有可靠的方法对这两种方式进行区分.</p>
<p><strong>不过我们是否可以转换看问题的角度, 针对通用的问题我们没有办法解决, 那么是不是可以找到一个更具体的问题去解决. If we can’t solve a general problem, can we solve a more specific one?</strong> </p>
<p>当我们定义一个 React 类组件时, 该组件一定会继承 <code>React.Component</code> 以便使用 React 的内部方法 <code>this.setState()</code> .  <strong>这样的话, 我们是否就不需要检测所有的类, 只需要检测继承 <code>React.Component</code> 的组件即可?</strong></p>
<p>剧透: 这就是React的处理方式.</p>
<hr>
<p>现在我们要检测 <code>Greeting</code> 是否是一个React 类组件, 最符合直觉的检测方式是 <code>Greeting.prototype instanceof React.Component</code> :</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(B.prototype <span class="keyword">instanceof</span> A); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>为了理解以上代码的含义, 我们首先要理解 JavaScript 原型.  </p>
<p>大家对”原型链”这个概念应该已经很熟悉了. 在JavaScript中, 所有对象可能存在一个”原型”. 当我们执行这段代码 <code>fred.sayHi()</code> 时, <code>fred</code> 这个对象本身可能并不存在 <code>sayHi</code> 属性. 我们会从 <code>fred</code> 的原型上寻找这个属性. 如果没有找到, 则会再深入原型链寻找 — <code>fred</code> 的原型的原型. 直到找到这个属性为止.</p>
<p>但比较令人疑惑的一点是, 类或者函数的 <code>prototype</code> 属性与它的原型并不对等.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype); <span class="comment">// 🤪 Not Person's prototype</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.__proto__); <span class="comment">// 😳 Person's prototype</span></span><br></pre></td></tr></table></figure>
<p>原型链的结构是 <code>__proto__.__proto__.__proto__</code> 而不是 <code>prototype.prototype.prototype</code> .</p>
<p>那这个 <code>prototype</code> 属性是什么呢?  当我们用 <code>new</code> 实例化一个类或者函数时, 实例的 <code>__proto__</code> 属性就是就是类或函数的 <code>prototype</code> 属性.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'Hi, I am '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fred = <span class="keyword">new</span> Person(<span class="string">'Fred'</span>); <span class="comment">// Sets `fred.__proto__` to `Person.prototype`</span></span><br></pre></td></tr></table></figure>
<p>JavaScript使用<strong><code>__proto__</code></strong> 链查询属性:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fred.sayHi();</span><br><span class="line"><span class="comment">// 1. Does fred have a sayHi property? No.</span></span><br><span class="line"><span class="comment">// 2. Does fred.__proto__ have a sayHi property? Yes. Call it!</span></span><br><span class="line"></span><br><span class="line">fred.toString();</span><br><span class="line"><span class="comment">// 1. Does fred have a toString property? No.</span></span><br><span class="line"><span class="comment">// 2. Does fred.__proto__ have a toString property? No.</span></span><br><span class="line"><span class="comment">// 3. Does fred.__proto__.__proto__ have a toString property? Yes. Call it!</span></span><br></pre></td></tr></table></figure>
<p>不过在实际应用中, 你不应该直接使用 <code>__proto__</code> , 除非调试时需要查询与原型链相关的信息. 如果你想使某些属性可以利用 <code>fred.__proto__</code> 访问, 就应该将该信息放在 <code>Person.prototype</code> . 这也是 <code>prototype</code> 设计的初衷.</p>
<p><code>__proto__</code> 属性其实并不应该暴露给外部, 因为它本质上只给 JavaScript 内部使用. 但是某些浏览器依然支持了该属性甚至将其标准化(不过它会逐渐被 <code>Object.getPrototypeOf()</code> 所替代的.)</p>
<p><strong>现在我依然疑惑的是: 对象的 <code>prototype</code> 属性对应的值竟然不是对象的原型</strong>(举个例子: <code>fred.prototype</code> 的值为 <code>undefined</code> , 因为 <code>fred</code> 不是一个函数). 个人认为, 这是开发者难以理解 JavaScript 原型概念的主要原因.</p>
<hr>
<p>现在我们知道了, 当我们输入 <code>obj.foo</code> 时, JavaScript 实际上会在 <code>obj</code> <code>obj.__proto__</code>, <code>obj.__proto__.__proto__</code> …上寻找 <code>foo</code> 属性.</p>
<p>在 JavaScript 类中, 并没有直接暴露这个机制, 不过 <code>extends</code> 的实现基于这种原型链机制. 这也是我们的 React 类实例读取 <code>setState</code> 方法所利用的机制:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Greeting();</span><br><span class="line"><span class="built_in">console</span>.log(c.__proto__); <span class="comment">// Greeting.prototype</span></span><br><span class="line"><span class="built_in">console</span>.log(c.__proto__.__proto__); <span class="comment">// React.Component.prototype</span></span><br><span class="line"><span class="built_in">console</span>.log(c.__proto__.__proto__.__proto__); <span class="comment">// Object.prototype</span></span><br><span class="line"></span><br><span class="line">c.render();      <span class="comment">// Found on c.__proto__ (Greeting.prototype)</span></span><br><span class="line">c.setState();    <span class="comment">// Found on c.__proto__.__proto__ (React.Component.prototype)</span></span><br><span class="line">c.toString();    <span class="comment">// Found on c.__proto__.__proto__.__proto__ (Object.prototype)</span></span><br></pre></td></tr></table></figure>
<p>也就是说, <strong>当我们使用类的时候, 类实例的 <code>__proto__</code> 链反映了这种原型链关系:</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `extends` chain</span></span><br><span class="line">Greeting</span><br><span class="line">  → React.Component</span><br><span class="line">    → <span class="built_in">Object</span> (implicitly)</span><br><span class="line"></span><br><span class="line"><span class="comment">// `__proto__` chain</span></span><br><span class="line"><span class="keyword">new</span> Greeting()</span><br><span class="line">  → Greeting.prototype</span><br><span class="line">    → React.Component.prototype</span><br><span class="line">      → <span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure>
<p>那么既然了解了 <code>__proto__</code> 链的概念, 我们就能通过这种方式检查 <code>Greeting</code> 是否继承自 <code>React.Component</code> , 从 <code>Greeting.prototype</code> 开始通过 <code>__proto__</code> 不断层层深入.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `__proto__` chain</span></span><br><span class="line"><span class="keyword">new</span> Greeting()</span><br><span class="line">  → Greeting.prototype <span class="comment">// 🕵️ We start here</span></span><br><span class="line">    → React.Component.prototype <span class="comment">// ✅ Found it!</span></span><br><span class="line">      → <span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure>
<p>还有一个更加方便的方式, <code>x instanceof Y</code> 也可以实现与以上代码几乎差不多的功能. 跟着 <code>x.__proro__</code> 的原型链寻找 <code>Y.prototype</code> .</p>
<p>正常情况下, 我们通过这种方式来判断类的实例:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting = <span class="keyword">new</span> Greeting();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greeting <span class="keyword">instanceof</span> Greeting); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// greeting (🕵️‍ We start here)</span></span><br><span class="line"><span class="comment">//   .__proto__ → Greeting.prototype (✅ Found it!)</span></span><br><span class="line"><span class="comment">//     .__proto__ → React.Component.prototype </span></span><br><span class="line"><span class="comment">//       .__proto__ → Object.prototype</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greeting <span class="keyword">instanceof</span> React.Component); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// greeting (🕵️‍ We start here)</span></span><br><span class="line"><span class="comment">//   .__proto__ → Greeting.prototype</span></span><br><span class="line"><span class="comment">//     .__proto__ → React.Component.prototype (✅ Found it!)</span></span><br><span class="line"><span class="comment">//       .__proto__ → Object.prototype</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greeting <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// greeting (🕵️‍ We start here)</span></span><br><span class="line"><span class="comment">//   .__proto__ → Greeting.prototype</span></span><br><span class="line"><span class="comment">//     .__proto__ → React.Component.prototype</span></span><br><span class="line"><span class="comment">//       .__proto__ → Object.prototype (✅ Found it!)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greeting <span class="keyword">instanceof</span> Banana); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// greeting (🕵️‍ We start here)</span></span><br><span class="line"><span class="comment">//   .__proto__ → Greeting.prototype</span></span><br><span class="line"><span class="comment">//     .__proto__ → React.Component.prototype </span></span><br><span class="line"><span class="comment">//       .__proto__ → Object.prototype (🙅‍ Did not find it!)</span></span><br></pre></td></tr></table></figure>
<p>同时也能用来判断某个类是否继承自另一个类:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Greeting.prototype <span class="keyword">instanceof</span> React.Component);</span><br><span class="line"><span class="comment">// greeting</span></span><br><span class="line"><span class="comment">//   .__proto__ → Greeting.prototype (🕵️‍ We start here)</span></span><br><span class="line"><span class="comment">//     .__proto__ → React.Component.prototype (✅ Found it!)</span></span><br><span class="line"><span class="comment">//       .__proto__ → Object.prototype</span></span><br></pre></td></tr></table></figure>
<p>以上这种方式可以用以区分React 类组件和函数组件.</p>
<hr>
<p>不过React在生产中并不是使用这种方式去检查的. 😳</p>
<p>使用 <code>instanceof</code> 的判断方式有个弊端, 当我们的页面中存在多个 React 的拷贝时,  我们检查的某个组件可能继承自另一个 React 拷贝的 <code>React.Component</code> . 在一个项目中使用多个 React 拷贝当然是不推荐的做法. 但是由于历史原因, 我们可能会用多个 React 拷贝来解决某些问题. (不过如果我们在项目中使用 Hooks 的话, <a href="https://github.com/facebook/react/issues/13991" target="_blank" rel="noopener">我们可能必须要禁止多个拷贝的存在</a>.)</p>
<p>另一个判断方式是, 检查原型链中的 <code>render</code> 方法是否存在. 然而, 当时对于<a href="https://github.com/facebook/react/issues/4599#issuecomment-129714112" target="_blank" rel="noopener">组件相关的 API 规范并没有完全确定下来.</a> 随时可能会变化. 如果使用这种方式的话, Every check has a cost so we wouldn’t want to add more than one. 同时, 如果 <code>render</code> 被定义为实例方法的话, 这种方式也会失效.</p>
<p>因此 React 采用了一种给基础组件<a href="https://github.com/facebook/react/pull/4663" target="_blank" rel="noopener">添加</a>特殊标志的方式. React 会检查这个标志是否存在, 通过这个标志来判断这是个类组件还是函数组件.</p>
<p>在最初的实现版本中, 这个标志存在于 <code>React.Compoenent</code> 本身:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inside React</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;&#125;</span><br><span class="line">Component.isReactClass = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We can check it like this</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Greeting.isReactClass); <span class="comment">// ✅ Yes</span></span><br></pre></td></tr></table></figure>
<p>然而, 一些类在<a href="https://github.com/scala-js/scala-js/issues/1900" target="_blank" rel="noopener">实现</a>上并没有拷贝静态属性或者设置非标准的 <code>__proto__</code> . 在这种情况下 React 添加的特殊标志就丢失了.</p>
<p>于是React团队<a href="https://github.com/facebook/react/pull/5021" target="_blank" rel="noopener">将这个标志转移</a>到了 <code>React.Component.prototype</code> 上了:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inside React</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;&#125;</span><br><span class="line">Component.prototype.isReactComponent = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We can check it like this</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Greeting.prototype.isReactComponent); <span class="comment">// ✅ Yes</span></span><br></pre></td></tr></table></figure>
<p>也许很多人会疑惑, 为什么我们的标识不是布尔值而是对象. 这是因为我们在使用 Jest 进行自动化测试时, 前几个版本的 Jest 默认打开了<a href="https://dev.to/slashgear_/discover-jest-hidden-feature-automock-2c9f" target="_blank" rel="noopener">automocking</a>, 生成的模拟测试数据会<a href="https://github.com/facebook/react/pull/4663#issuecomment-136533373" target="_blank" rel="noopener">忽略原始值</a>, 因此如果用布尔值的话, 会影响自动化测试的结果.</p>
<p><code>isReactComponent</code> 的检测方式至今依然在<a href="https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/react-reconciler/src/ReactFiber.js#L297-L300" target="_blank" rel="noopener">使用</a>. </p>
<p>如果你在编写React组件的时候没有继承 <code>React.Component</code> . React就不会在原型链中找到 <code>isReactComponent</code> 这个属性, 也不会将其看做 class 组件. 读到这里, 大家可能就都明白<a href="https://stackoverflow.com/questions/38481857/getting-cannot-call-a-class-as-a-function-in-my-react-project/42680526#42680526" target="_blank" rel="noopener">这个问题</a>的答案了: 如果在React的开发过程中遇到 <code>Cannot call a class as a function</code> 的报错, 记得在使用React 类组件时加上 <code>extends React.Component</code> . 同时如果你没有这样使用类组件, 却组件内却定义了 <code>render</code> 方法, React也会报出一个<a href="https://github.com/facebook/react/pull/11168" target="_blank" rel="noopener">⚠️</a>. </p>
<hr>
<p>你可能会觉得这篇文章有点挂羊头卖狗肉 (<a href="https://en.wikipedia.org/wiki/Bait-and-switch" target="_blank" rel="noopener">bait-and-switch</a>) 的感觉. <strong>实际的解决方案那么简单, 可是我们却不直接回答这个问题, 而是饶了那么一大圈去解释为什么替代方案是不可行的.</strong> </p>
<p>在我的经验中, 在实现一个库的 API 时, 这是经常会遇到的情况. 对于一个使用起来很方便的 API, 你必须要深入考虑语言本身的语义, 运行时的性能, 存在/不存在编译步骤时的效率, 相关生态的发展以及打包方案, 早期的告警以及很多其他问题. 最终设计出成果或许不会是最优雅的, 但是肯定是最实用的.</p>
<p>如果最终设计出来的 API 很成功的话, 那么 API 的使用者就完全不需要考虑它的设计过程, 只需要专注于创建应用即可.</p>
<p>如果使用者对 API 的设计感到好奇, 了解它的底层原理当然是很好的.</p>
</div></article></div></main><footer><div class="paginator"><a href="/posts/2020/01/22/how-does-setstate-know-what-to-do/" class="prev">PREV</a><a href="/posts/2019/06/27/element-in-view/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 - 2023 <a href="https://icyfish.github.io/posts">Fish</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>