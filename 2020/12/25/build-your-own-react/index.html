<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="IDYUPnBNhdnU8o9LRNKZ1RSt14tIxTI0rLeMrBtswXw"><title> 实现自己的 React · Fish</title><meta name="description" content="实现自己的 React - Fish"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/posts/favicon.png"><link rel="stylesheet" href="/posts/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://icyfish.github.io/posts/atom.xml" title="Fish"><meta name="generator" content="Hexo 7.0.0-rc1"></head><body><div class="wrap"><header><a href="/posts/" class="logo-link"><img src="/posts/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/posts/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/posts/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/posts/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="http://twitter.com/icyfish_" target="_blank" class="nav-list-link">TWITTER</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">实现自己的 React</h1><div class="post-info">Dec 25, 2020</div><div class="post-content"><p>原文: <a href="https://pomb.us/build-your-own-react/" target="_blank" rel="noopener">Build your own React</a></p>
<!-- ```toc
# This code block gets replaced with the TOC
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">这是一个从零开始实现 React 的教程，与生产版本有所差异的是，我们会忽略所有优化的细节，同时忽略一些与主要原理无关的特性。</span><br><span class="line"></span><br><span class="line">也许你阅读过我之前写过的[类似教程](https:&#x2F;&#x2F;engineering.hexacta.com&#x2F;didact-learning-how-react-works-by-building-it-from-scratch-51007984e5c5)，这篇教程与之前教程的区别是，本教程的源代码基于 React 16.8 版本，因此本教程包含了 hooks 的特性，同时不包含 class 版本组件的实现。</span><br><span class="line"></span><br><span class="line">如果你同时希望学习旧版本的实现，可以查看旧版的教程以及与之相关的旧版[实现源码](https:&#x2F;&#x2F;github.com&#x2F;pomber&#x2F;didact)。同时还有一个[视频解说](https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v&#x3D;8Kc2REHdwnQ&amp;feature&#x3D;youtu.be)以供参考。不过阅读本教程并不强制要求你学习过之前的版本，本教程的内容是独立完整的。</span><br><span class="line"></span><br><span class="line">我将实现过程拆分成了以下几个部分：</span><br><span class="line"></span><br><span class="line">1. 实现 &#96;createElement&#96; 函数</span><br><span class="line">2. 实现 &#96;render&#96; 函数</span><br><span class="line">3. Concurrent 模式</span><br><span class="line">4. Fibers</span><br><span class="line">5. 渲染与提交阶段 (Commit)</span><br><span class="line">6. 协调 Reconciliation</span><br><span class="line">7. 函数式组件</span><br><span class="line">8. Hooks</span><br><span class="line"></span><br><span class="line">## 概览</span><br><span class="line"></span><br><span class="line">首先我们来看几个基本概念。如果你对 React，JSX 和 DOM 元素的实现已经有了比较深刻的理解，可以跳过这部分的介绍直接进入下一部分。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;tsx</span><br><span class="line">const element &#x3D; &lt;h1 title&#x3D;&quot;foo&quot;&gt;Hello&lt;&#x2F;h1&gt;</span><br><span class="line">const container &#x3D; document.getElementById(&quot;root&quot;)</span><br><span class="line">ReactDOM.render(element, container)</span><br></pre></td></tr></table></figure>
<p>这是一个简单的 React 应用，仅仅包含了三行代码。第一行定义了一个 React 元素。第二行利用 Web API 获取了 DOM 中的某一个节点，我将它称为容器。最后一行则是将我们的 React 元素插入到容器的操作。</p>
<p><strong>现在我们把所有 React 相关的代码全部替换为原生 JavaScript 代码。</strong></p>
<p>第一行代码，使用的是 JSX 语法，它并不是原生的 JavaScript 代码，因此我们对它做出一些修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const element &#x3D; React.createElement(</span><br><span class="line">  &quot;h1&quot;,</span><br><span class="line">  &#123; title: &quot;foo&quot; &#125;,</span><br><span class="line">  &quot;Hello&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>JSX 代码会被类似 Babel 的编译工具进行处理，转换成原生 JavaScript 代码。转换过程比较简单：将 <code>&lt;</code> <code>&gt;</code> 标签移除，使用 <code>createElement</code> 函数调用进行替换，传入的参数分别为：标签名称，元素参数，以及元素的子元素。</p>
<p><code>React.createElement</code> ，根据所传入的参数，创建了一个对象。除了一些有效性校验之外，整体的功能就是以上这样。因此我们可以直接把 JSX 替换成原生 JavaScript 的形式，人工确保元素和属性等的有效性。</p>
<p>经过以上处理之后，我们的元素就变成了这样的形式：一个对象，内部含有两个属性，分别是 <code>type</code> 和 <code>props</code> (当然了，实际上<a href="https://github.com/facebook/react/blob/f4cc45ce962adc9f307690e1d5cfa28a288418eb/packages/react/src/ReactElement.js#L111" target="_blank" rel="noopener">包含更多</a>，目前我们只关注这两个就可以。）</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  type: <span class="string">"h1"</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: <span class="string">"foo"</span>,</span><br><span class="line">    children: <span class="string">"Hello"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>type</code> 属性的值是字符串类型，表示我们所希望创建的 DOM 元素类型，相当于当你希望创建一个 HTML 元素的时候，传入 <code>document.createElement</code> 函数中的标签名。当然除了字符串类型之外，<code>type</code> 的值还可以是一个函数，这点我们会在函数式组件的那一部分中详细介绍。</p>
<p><code>props</code> 是另一个对象，其中的内容包括所有 JSX 属性中的键值对。有一个特殊的属性需要特别关注，就是 <code>children</code> 。</p>
<p>在我们当前的示例中，<code>children</code> 的值是一个字符串，不过在大多数情况下，<code>children</code> 的值会是一个包含很多元素的数组。这也是为什么, 元素的数据结构是树的原因。</p>
<p>我们的简易 React 应用中，第三行代码（<code>ReactDOM.render</code>）也不是原生的 JavaScript 代码，同样需要进行转换。</p>
<p>在 <code>render</code> 方法中，React 元素被转换并渲染到了 DOM 中，现在我们要用自己的方法去实现这一步。</p>
<p>首先需要做的是，利用第一步的 <code>type</code> 属性，创建一个 DOM 节点，本例中我们的 <code>type</code> 属性是 <code>h1</code> 标签。</p>
<p>然后，我们将所有元素属性都赋到对应的 DOM 节点中。本例中只有 title 属性。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> node = <span class="built_in">document</span>.createElement(element.type)</span><br><span class="line">node[<span class="string">"title"</span>] = element.props.title</span><br></pre></td></tr></table></figure>
<p>为了避免混淆，我会用“元素”来表示 React 元素，“节点”来表示 DOM 元素。</p>
<p>接下来要处理子元素所对应的节点了。本例中我们的子元素是文本，因此只需要创建一个文本节点即可。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">""</span>)</span><br><span class="line">text[<span class="string">"nodeValue"</span>] = element.props.children</span><br></pre></td></tr></table></figure>
<p>渲染文本节点使用的是 <code>createTextNode</code> 而不是 <code>innerText</code>, 可以保证在后续处理元素时, 所有元素的形式都是一致的, 抹平差异, 统一处理. 使用 <code>createTextNode</code> 时, 文本也是属性, key 为 <code>nodeValue</code> ，与之前针对 <code>h1</code> 的处理是类似的：<code>props: {nodeValue: &quot;hello&quot;}</code> </p>
<p>最后将 <code>textNode</code> 添加到 <code>h1</code> ，将 <code>h1</code> 添加到容器中。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  type: <span class="string">"h1"</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: <span class="string">"foo"</span>,</span><br><span class="line">    children: <span class="string">"Hello"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> node = <span class="built_in">document</span>.createElement(element.type)</span><br><span class="line">node[<span class="string">"title"</span>] = element.props.title</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">""</span>)</span><br><span class="line">text[<span class="string">"nodeValue"</span>] = element.props.children</span><br><span class="line"></span><br><span class="line">node.appendChild(text)</span><br><span class="line">container.appendChild(node)</span><br></pre></td></tr></table></figure>
<p>至此，我们实现了与之前一致的应用，并且没有使用任何与 React 相关的代码。</p>
<h2 id="实现-createElement-函数"><a href="#实现-createElement-函数" class="headerlink" title="实现 createElement 函数"></a>实现 createElement 函数</h2><p>现在我们开始实现另一个应用。这次将 React 相关的代码替换成我们自己版本的 React。</p>
<p>首先开始实现我们的 <code>createElement</code> 。</p>
<p>还是先将 JSX 转换成 JS，以便看到 <code>createElement</code> 函数调用。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;div id=<span class="string">"foo"</span>&gt;</span><br><span class="line">    &lt;a&gt;bar&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">    &lt;b /</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp">const container = document.getElementById("root")</span></span><br><span class="line"><span class="regexp">ReactDOM.render(element, container)</span></span><br></pre></td></tr></table></figure>
<p>在之前的步骤中我们知道了：元素就是一个对象，内含有 <code>type</code> 和 <code>props</code> 属性。因此我们的 <code>createElement</code> 函数需要做的就是创建这个元素对象。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, ...children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    props: &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      children,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用  ES6 中的展开操作符来处理 <code>props</code> 属性，剩余参数语法来处理 <code>children</code> 属性，这样的话 <code>children</code> 属性就始终是一个数组。</p>
<p>举个例子，<code>createElement(&quot;div&quot;)</code> 函数返回的内容是：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"div"</span>,</span><br><span class="line">  <span class="attr">"props"</span>: &#123; <span class="attr">"children"</span>: [] &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>createElement(&quot;div&quot;, null, a)</code> 函数返回的内容是：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"div"</span>,</span><br><span class="line">  <span class="attr">"props"</span>: &#123; <span class="attr">"children"</span>: [a] &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>createElement(&quot;div&quot;, null, a, b)</code> 函数返回的内容是：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"div"</span>,</span><br><span class="line">  <span class="attr">"props"</span>: &#123; <span class="attr">"children"</span>: [a, b] &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>children</code> 数组的内容还可以是原始类型的值，字符串或者数字。现在我们将所有非对象类型的元素用一个特殊的类型 <code>TEXT_ELEMENT</code> 来表示。</p>
<p>在没有 <code>children</code> 的情况下，React 不会封装原始类型的值或者是创建一个空数组，我们这样做的原因是为了简化代码，毕竟简单的代码更利于教学。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, ...children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    props: &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      children: children.map(<span class="function"><span class="params">child</span> =&gt;</span></span><br><span class="line">        <span class="keyword">typeof</span> child === <span class="string">"object"</span></span><br><span class="line">          ? child</span><br><span class="line">          : createTextElement(child)</span><br><span class="line">      ),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTextElement</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">"TEXT_ELEMENT"</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">      nodeValue: text,</span><br><span class="line">      children: [],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = React.createElement(</span><br><span class="line">  <span class="string">"div"</span>,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">"foo"</span> &#125;,</span><br><span class="line">  React.createElement(<span class="string">"a"</span>, <span class="literal">null</span>, <span class="string">"bar"</span>),</span><br><span class="line">  React.createElement(<span class="string">"b"</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>)</span><br><span class="line">ReactDOM.render(element, container)</span><br></pre></td></tr></table></figure>
<p>目前我们依然在用 React 的 <code>createElement</code> 。</p>
<p>现在给我们自己的库起个名字，来替换它。为了体现它的教学意义，又保持与 React 的名字类似，我们将这个库叫做 Didact 。</p>
<p>不过我还是想要使用 JSX 语法，因此我们需要告诉 babel，去使用 Didact 的 <code>createElement</code> 而不是 React 的 <code>createElement</code> 。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Didact = &#123;</span><br><span class="line">  createElement,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = Didact.createElement(</span><br><span class="line">  <span class="string">"div"</span>,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">"foo"</span> &#125;,</span><br><span class="line">  Didact.createElement(<span class="string">"a"</span>, <span class="literal">null</span>, <span class="string">"bar"</span>),</span><br><span class="line">  Didact.createElement(<span class="string">"b"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>只需要简单地加上这个注释，就能够达到我们的目的了：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@jsx </span>Didact.createElement */</span></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;div id=<span class="string">"foo"</span>&gt;</span><br><span class="line">    &lt;a&gt;bar&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">    &lt;b /</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>
<h2 id="实现-render-方法"><a href="#实现-render-方法" class="headerlink" title="实现 render 方法"></a>实现 render 方法</h2><p>接下来我们要开始实现自己的 <code>ReactDOM.render</code> 函数。</p>
<p>目前，我们只需要关注在 DOM 中添加内容即可。元素的更新和删除都在后续的章节中进行阐述。</p>
<p>首先使用元素的类型创建 DOM 节点，然后将所创建的节点添加到我们的容器中。</p>
<p>针对所有的 <code>children</code> 都要去递归地处理。</p>
<p>与此同时还要处理文本类型的元素，创建文本节点而非普通节点。</p>
<p>最后将元素的属性都添加到 node 节点中。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dom =</span><br><span class="line">    element.type == <span class="string">"TEXT_ELEMENT"</span></span><br><span class="line">      ? <span class="built_in">document</span>.createTextNode(<span class="string">""</span>)</span><br><span class="line">      : <span class="built_in">document</span>.createElement(element.type)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isProperty = <span class="function"><span class="params">key</span> =&gt;</span> key !== <span class="string">"children"</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(element.props)</span><br><span class="line">    .filter(isProperty)</span><br><span class="line">    .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      dom[name] = element.props[name]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  element.props.children.forEach(<span class="function"><span class="params">child</span> =&gt;</span></span><br><span class="line">    render(child, dom)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  container.appendChild(dom)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上整体代码见：<a href="https://codesandbox.io/s/didact-2-k6rbj" target="_blank" rel="noopener">React</a>.</p>
<h2 id="实现-Concurrent-模式"><a href="#实现-Concurrent-模式" class="headerlink" title="实现 Concurrent 模式"></a>实现 Concurrent 模式</h2><p>在开始实现 Concurrent 模式之前要对我们的代码进行重构。</p>
<p>之前版本的递归调用有一点问题:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.props.children.forEach(<span class="function"><span class="params">child</span> =&gt;</span></span><br><span class="line">  render(child, dom)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>一旦组件开始进行渲染的进程，只有等全部的组件树渲染完毕后渲染流程才会结束。如果组件树过大的话，会长时间阻碍主进程。当浏览器要执行优先级高的操作（比如处理用户输入或者动画时），都需要等待渲染的结束，对性能造成比较大的影响。</p>
<p>因此我们要将渲染的流程拆分成一个个小的单元，在各个单元之间，我们可以暂停渲染进程，允许浏览器执行其他操作。</p>
<p>我们使用 <code>[requestIdleCallback](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback)</code> (浏览器提供的一个 API )来创建一个循环。为了便于理解可以将 <code>requestIdleCallback</code> 看作是 <code>setTimeout</code>，区别就是，<code>setTimeout</code> 受时间控制，而 <code>requestIdleCallback</code>  则是在主进程处于空闲的情况下被浏览器执行的。</p>
<p>现在 <a href="https://github.com/facebook/react/issues/11171#issuecomment-417349573" target="_blank" rel="noopener">React 已经不再使用</a> <code>requestIdleCallback</code> 了，目前它的替代方案是 <a href="https://github.com/facebook/react/tree/master/packages/scheduler" target="_blank" rel="noopener">scheduler</a> 包。不过两者所实现的主要功能相差无几。</p>
<p><code>requestIdleCallback</code> 还接受一个类似最后期限 （deadline）的参数。我们可以利用这个参数知道浏览器还有多长时间之后, 会重新获取控制权。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> shouldYield = <span class="literal">false</span> <span class="comment">// 停止操作的 flag</span></span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class="line">    nextUnitOfWork = performUnitOfWork(</span><br><span class="line">      nextUnitOfWork</span><br><span class="line">    )</span><br><span class="line">    shouldYield = deadline.timeRemaining() &lt; <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  requestIdleCallback(workLoop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">requestIdleCallback(workLoop)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">nextUnitOfWork</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>截止本文撰写的时间（2019年11月），Concurrent 模式在 React 中还并非稳定特性，处于实验阶段。稳定版本的循环代码大概像是下面这样：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (nextUnitOfWork) &#123;    </span><br><span class="line">  nextUnitOfWork = performUnitOfWork(   </span><br><span class="line">    nextUnitOfWork  </span><br><span class="line">  ) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要想开始这段循环 (workLoop)，首先要设置首个单元的进程，然后实现 <code>performUnitOfWork</code> 函数，处理当前单元的渲染进程，并返回下一个单元的进程。</p>
<h2 id="Fibers"><a href="#Fibers" class="headerlink" title="Fibers"></a>Fibers</h2><p>想要组织渲染进程的各个单元，我们需要依赖的数据结构是 fiber 树。</p>
<p>一个 fiber 代表每一个元素，而每一个 fiber 也是进程的一个单元。</p>
<p>下面看这个例子。</p>
<p>假设我们需要渲染的元素类似如下这样, 他的 fiber 树就如右图.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Didact.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;</span><br><span class="line">      &lt;p /&gt;</span><br><span class="line">      &lt;a /&gt;</span><br><span class="line">    &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;h2 /</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;,</span></span><br><span class="line"><span class="regexp">  container</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>
<p><img src="/posts/images/fiber.png" alt="fiber"></p>
<p>在 <code>render</code> 方法中， 我们会创建一个根 fiber, 然后将其设置为 <code>nextUnitOfWork</code> (下一个执行单元）。之后的流程则在 <code>performUnitOfWork</code> (执行当前工作单元)函数中实现，在这个函数中，我们会针对每一个 fiber 执行如下操作：</p>
<ol>
<li>将元素添加到 DOM 中</li>
<li>为元素的子元素创建各自的 fiber</li>
<li>返回下一个执行单元(需要被处理的 fiber)</li>
</ol>
<p>我们选择 fiber 数据结构的原因是便于找到下一个执行单元。这也是为什么每一个 fiber 都与它的第一个子节点，相邻的兄弟节点和父节点都存在关联关系的原因。</p>
<p>当我们在<code>performUnitOfWork</code> 中做好处理 fiber 的任务之后,  如果这个 fiber 有一个 <code>child</code> 子节点，那么这个子节点对应的 fiber 就是下一个执行单元。</p>
<p>在我们的示例中，<code>h1</code> 是 <code>div</code> 之后的一个执行单元 。</p>
<p>如果某个 fiber 没有子节点的话，那么紧接的执行单元就是兄弟节点。</p>
<p>例子中，fiber <code>p</code> 没有子节点，因此 <code>a</code> 就是下一个执行单元。</p>
<p>如果 fiber 既没有子节点，也没有兄弟节点，那么就会寻找该 fiber 的”叔叔节点”：也就是父节点的兄弟节点，就比如我们例子中的 <code>a</code> 和 <code>h2</code> 。</p>
<p>如果父节点不存在兄弟节点，那么我们还会不断向上追溯，寻找这类节点，直到到达根节点为止。到了根节点也意味着，针对这次渲染的所有细分单元工作, 我们均已完成。</p>
<p>现在以代码形式来呈现这一切。</p>
<p>首先从 <code>render</code> 中删除渲染的代码, 我们将具体的渲染工作都交付给 <code>performUnitOfWork</code></p>
<p>将创建 DOM 节点的方法封装成 <code>createDom</code>，后续使用。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createDOM</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dom =</span><br><span class="line">    element.type == <span class="string">"TEXT_ELEMENT"</span></span><br><span class="line">      ? <span class="built_in">document</span>.createTextNode(<span class="string">""</span>)</span><br><span class="line">      : <span class="built_in">document</span>.createElement(element.type);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isProperty = <span class="function">(<span class="params">key</span>) =&gt;</span> key !== <span class="string">"children"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.keys(element.props)</span><br><span class="line">    .filter(isProperty)</span><br><span class="line">    .forEach(<span class="function">(<span class="params">propName</span>) =&gt;</span> &#123;</span><br><span class="line">      dom[propName] = element.props[propName];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>render</code> 方法中，我们给 <code>nextUnitOfWork</code> (下一个工作单元）赋值为 fiber 树的根节点。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  nextUnitOfWork = &#123;</span><br><span class="line">    dom: container,</span><br><span class="line">    props: &#123;</span><br><span class="line">      children: [element],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当浏览器准备就绪的时候，会调用 <code>workLoop</code> 方法，于是就会从根节点开始我们的渲染进程。</p>
<p>在 <code>performUnitOfWork</code> 方法中: </p>
<p>我们首先创建一个新的节点, 然后将其添加到 DOM 中。这个新节点会存储在 <code>fiber.dom</code> 中:</p>
<p>然后针对每一个子元素，我们都创建一个新的 fiber 。</p>
<p>之后将其添加到 fiber 树中，根据情况设置为子节点或者是兄弟节点。</p>
<p>最后我们实现对下一个工作单元的搜寻工作。首先是子节点，接着是兄弟节点，然后是叔叔节点，以此类推。</p>
<p>最后就实现了 <code>performUnitOfWork</code> 方法。下面是完整的代码：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 新增 DOM 节点</span></span><br><span class="line">  <span class="keyword">if</span> (!fiber.dom) &#123;</span><br><span class="line">    fiber.dom = createDom(fiber)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.parent) &#123;</span><br><span class="line">    fiber.parent.dom.appendChild(fiber.dom)</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 对每一个 child 都创建一个新的 fiber </span></span><br><span class="line">  <span class="keyword">const</span> elements = fiber.props.children</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> prevSibling = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (index &lt; elements.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newFiber = &#123;</span><br><span class="line">      type: element.type,</span><br><span class="line">      props: element.props,</span><br><span class="line">      parent: fiber,</span><br><span class="line">      dom: <span class="literal">null</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      fiber.child = newFiber</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      prevSibling.sibling = newFiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prevSibling = newFiber</span><br><span class="line">    index++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.child) &#123;</span><br><span class="line">    <span class="keyword">return</span> fiber.child</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> nextFiber = fiber</span><br><span class="line">  <span class="keyword">while</span> (nextFiber) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextFiber.sibling) &#123;</span><br><span class="line">      <span class="keyword">return</span> nextFiber.sibling</span><br><span class="line">    &#125;</span><br><span class="line">    nextFiber = nextFiber.parent</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="渲染与提交阶段-Commit"><a href="#渲染与提交阶段-Commit" class="headerlink" title="渲染与提交阶段 Commit"></a>渲染与提交阶段 Commit</h2><p>现在我们又遇到了另一个问题。</p>
<p>每开始处理一个元素，我们都会创建一个新的节点到 DOM 中。但是根据目前的代码实现, 在整棵树在 DOM 中渲染完成之前，浏览器是有机会阻碍我们渲染流程的进行的。这样的话，用户就很可能会在此过程中看见一个不完整的 UI ，这不是我们所期待的行为。</p>
<p>因此我们要把引起 DOM 变化部分的代码移除。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~~<span class="keyword">if</span> (fiber.parent) &#123;</span><br><span class="line">    fiber.parent.dom.appendChild(fiber.dom)</span><br><span class="line">  &#125;~~</span><br></pre></td></tr></table></figure>
<p>同时，要开始监视 fiber 树根节点的变化。我们将监视变化的节点叫做 <code>wipRoot</code> 。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  wipRoot = &#123;</span><br><span class="line">    dom: container,</span><br><span class="line">    props: &#123;</span><br><span class="line">      children: [element],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  nextUnitOfWork = wipRoot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> wipRoot = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// 见上</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦所有工作完成之后（当没有下一个工作单元的时候，就表示所有工作都完成了），再将最终的 fiber 树交给 DOM。</p>
<p>这部分的工作，交给 <code>commitRoot</code> 函数来完成。在这里我们递归地将所有节点添加到 DOM 中。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  commitWork(wipRoot.child)</span><br><span class="line">  wipRoot = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> domParent = fiber.parent.dom</span><br><span class="line">  domParent.appendChild(fiber.dom)</span><br><span class="line">  commitWork(fiber.child)</span><br><span class="line">  commitWork(fiber.sibling)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="协调-Reconciliation"><a href="#协调-Reconciliation" class="headerlink" title="协调 Reconciliation"></a>协调 Reconciliation</h2><p>截止目前，我们依然只是简单地添加节点到 DOM 中，那么更新和删除 DOM 节点需要怎么处理呢？</p>
<p>接下来要开始这部分的处理，我们要对在 <code>render</code> 方法中获取到的 fiber 树，与前一次已经插入到 DOM 中的 fiber 树进行对比。</p>
<p>因此，我们需要在 fiber 树在被插入 DOM 中之前，把它缓存下来，作为对比的对象，我们把它叫做：<code>currentRoot</code> </p>
<p>对于每一个 fiber，我们还会添加一个属性：<code>alternate</code> ，它是与旧版本 fiber 的连接，也就是之前缓存下来的前一个版本的 fiber 树中的内容。</p>
<p>现在将 <code>performUnitOfWork</code> 方法中创建新 fiber 的代码提取出来，添加到一个名为 <code>reconcileChildren</code> 方法中。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber.dom) &#123;</span><br><span class="line">    fiber.dom = createDom(fiber)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> elements = fiber.props.children</span><br><span class="line">  reconcileChildren(fiber, elements)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.child) &#123;</span><br><span class="line">    <span class="keyword">return</span> fiber.child</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> nextFiber = fiber</span><br><span class="line">  <span class="keyword">while</span> (nextFiber) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextFiber.sibling) &#123;</span><br><span class="line">      <span class="keyword">return</span> nextFiber.sibling</span><br><span class="line">    &#125;</span><br><span class="line">    nextFiber = nextFiber.parent</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们开始处理旧的 fiber 和新的元素们。</p>
<p>同时对旧 fiber 的子节点们（<code>wipFiber.alternate</code>）和新元素的数组进行循环遍历的操作。</p>
<p>如果我们忽略所有进行循环遍历的样板代码，会发现在循环中最重要的内容是 <code>oldFiber</code> 和 <code>element</code> 。<code>**element</code> 是我们希望渲染到 DOM 中的内容，<code>oldFiber</code> 是前一次渲染的 fiber 树。**</p>
<p>我们需要对它们进行对比, 以确定我们是否需要对 DOM 做出任何修改的操作.</p>
<p>具体方式是对比类型:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sameType = oldFiber &amp;&amp; element &amp;&amp; element.type == oldFiber.type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">  <span class="comment">// TODO update the node</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class="line">  <span class="comment">// TODO add this node</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class="line">  <span class="comment">// TODO delete the oldFiber's node</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果旧的 fiber 和新的元素类型是一样的, 我们就保持原先的 DOM 节点, 直接使用新的 props 更新.</li>
<li>如果两个类型不一致, 并且有新的元素出现, 那么我们就要创建一个新的 DOM 节点.</li>
<li>如果两个类型不一致, 但是旧的 filber 依然存在, 那么我们就要移除旧有节点.</li>
</ul>
<p>在这里, React 还使用了 key 以更好地实现协调. 举个例子, 当元素的子元素在元素数组中改变位置时, 也会被检测到.</p>
<p>当旧的 fiber 与新的元素类型一致时, 我们开始创建一个新的 fiber 来隔离 DOM 节点与旧的 fiber, 以及元素中传下来的 props.</p>
<p>与此同时, 我们还会给 fiber 添加一个新的属性: <code>effectTag</code> , 在提交阶段使用:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">  newFiber = &#123;</span><br><span class="line">    type: oldFiber.type,</span><br><span class="line">    props: element.props,</span><br><span class="line">    dom: oldFiber.dom,</span><br><span class="line">    parent: wipFiber,</span><br><span class="line">    alternate: oldFiber,</span><br><span class="line">    effectTag: <span class="string">"UPDATE"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于需要一个新 DOM 节点的情况, 我们将 <code>effectTag</code> 的值设为 <code>PLACEMENT</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class="line">  newFiber = &#123;</span><br><span class="line">    type: element.type,</span><br><span class="line">    props: element.props,</span><br><span class="line">    dom: <span class="literal">null</span>,</span><br><span class="line">    parent: wipFiber,</span><br><span class="line">    alternate: <span class="literal">null</span>,</span><br><span class="line">    effectTag: <span class="string">"PLACEMENT"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是需要删除 DOM 节点的情况, 我们不需要创建新 fiber, 只需要将值为 <code>DELETION</code> 的 <code>effectTag</code> 属性添加到旧的 fiber 上即可.</p>
<p>不过当我们将这个 fiber 树提交给 DOM 时, 需要通过 work in progress 节点 (<code>wipRoot</code>), 其中不包含旧的 fibers.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class="line">  oldFiber.effectTag = <span class="string">"DELETION"</span>;</span><br><span class="line">  deletions.push(oldFiber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此我们需要有一个数组来存储需要被删除的 fibers.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  wipRoot = &#123;</span><br><span class="line">    dom: container,</span><br><span class="line">    props: &#123;</span><br><span class="line">      children: [element],</span><br><span class="line">    &#125;,</span><br><span class="line">    alternate: currentRoot,</span><br><span class="line">  &#125;</span><br><span class="line">  deletions = []</span><br><span class="line">  nextUnitOfWork = wipRoot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> currentRoot = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> wipRoot = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> deletions = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>当我们将改动提交给 DOM 时, 我们需要的就是以上数组中的 fibers.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  deletions.forEach(commitWork)</span><br><span class="line">  commitWork(wipRoot.child)</span><br><span class="line">  currentRoot = wipRoot</span><br><span class="line">  wipRoot = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们开始修改 <code>commitWork</code> 函数以处理这些新的 <code>effectTag</code>.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> domParent = fiber.parent.dom</span><br><span class="line">  domParent.appendChild(fiber.dom)</span><br><span class="line">  commitWork(fiber.child)</span><br><span class="line">  commitWork(fiber.sibling)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 fiber 的 effectTag 属性值为 <code>PLACEMENT</code>, 我们还是执行同样的操作, 将 DOM 节点添加到父 fiber 对应的节点中,</p>
<p>如果是 <code>DELETION</code> 的话, 则删除这个子节点.</p>
<p>如果是 <code>UPDATE</code> 的话, 则更新已存在的 DOM 节点, 同时更新 props, 具体的操作在 <code>updateDom</code> 方法中实现</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> domParent = fiber.parent.dom;</span><br><span class="line">  <span class="keyword">if</span> (fiber.effectTag === <span class="string">"PLACEMENT"</span> &amp;&amp; fiber.dom != <span class="literal">null</span>) &#123;</span><br><span class="line">    domParent.appendChild(fiber.dom);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.effectTag === <span class="string">"UPDATE"</span> &amp;&amp; fiber.dom != <span class="literal">null</span>) &#123;</span><br><span class="line">    updateDom(fiber.dom, fiber.alternate.props, fiber.props);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.effectTag === <span class="string">"DELETION"</span>) &#123;</span><br><span class="line">    domParent.removeChild(fiber.dom);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  commitWork(fiber.child);</span><br><span class="line">  commitWork(fiber.sibling);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>updateDom</code> 中, 我们对比新旧 fiber 中的 props, 移除已经不存在的 props, 更新新建的或者是已经改变的 props.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isProperty = <span class="function"><span class="params">key</span> =&gt;</span> key !== <span class="string">"children"</span></span><br><span class="line"><span class="keyword">const</span> isNew = <span class="function">(<span class="params">prev, next</span>) =&gt;</span> <span class="function"><span class="params">key</span> =&gt;</span></span><br><span class="line">  prev[key] !== next[key]</span><br><span class="line"><span class="keyword">const</span> isGone = <span class="function">(<span class="params">prev, next</span>) =&gt;</span> <span class="function"><span class="params">key</span> =&gt;</span> !(key <span class="keyword">in</span> next)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateDom</span>(<span class="params">dom, prevProps, nextProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Remove old properties</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(prevProps)</span><br><span class="line">    .filter(isProperty)</span><br><span class="line">    .filter(isGone(prevProps, nextProps))</span><br><span class="line">    .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      dom[name] = <span class="string">""</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set new or changed properties</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(nextProps)</span><br><span class="line">    .filter(isProperty)</span><br><span class="line">    .filter(isNew(prevProps, nextProps))</span><br><span class="line">    .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      dom[name] = nextProps[name]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中有一类 prop 比较特殊, 就是事件处理器, 我们通过 prop 名中是否含有 <code>on</code> 前缀来判断是否是这类 prop.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEvent = <span class="function"><span class="params">key</span> =&gt;</span> key.startsWith(<span class="string">"on"</span>)</span><br><span class="line"><span class="keyword">const</span> isProperty = <span class="function"><span class="params">key</span> =&gt;</span></span><br><span class="line">  key !== <span class="string">"children"</span> &amp;&amp; !isEvent(key)</span><br></pre></td></tr></table></figure>
<p>如果事件处理函数有任何变化, 我们就从旧的节点中删除它</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Remove old or changed event listeners</span></span><br><span class="line"><span class="built_in">Object</span>.keys(prevProps)</span><br><span class="line">  .filter(isEvent)</span><br><span class="line">  .filter(<span class="function"><span class="params">key</span> =&gt;</span> !(key <span class="keyword">in</span> nextProps) || isNew(prevProps, nextProps)(key))</span><br><span class="line">  .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> eventType = name.toLowerCase().substring(<span class="number">2</span>);</span><br><span class="line">    dom.removeEventListener(eventType, prevProps[name]);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>同时添加修改后的事件处理函数:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add event listeners</span></span><br><span class="line"><span class="built_in">Object</span>.keys(nextProps)</span><br><span class="line">  .filter(isEvent)</span><br><span class="line">  .filter(isNew(prevProps, nextProps))</span><br><span class="line">  .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> eventType = name.toLowerCase().substring(<span class="number">2</span>);</span><br><span class="line">    dom.addEventListener(eventType, nextProps[name]);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>含有协调功能的 react 实现完整代码: <a href="https://github.com/icyfish/didact/blob/master/src/index_v2.jsx" target="_blank" rel="noopener">React With Reconcilation</a></p>
<h2 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h2><p>接下来我们要做的是支持函数组件.</p>
<p>首先修改示例. 我们使用一个简单的函数式组件, 它返回一个 <code>h1</code> 元素.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@jsx </span>Didact.createElement */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hi &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">name</span>=<span class="string">"foo"</span> /&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>)</span><br><span class="line">Didact.render(element, container)</span><br></pre></td></tr></table></figure>
<p>将 jsx 转换成 js 的话, 就是这样:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Didact.createElement(</span><br><span class="line">    <span class="string">"h1"</span>,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="string">"Hi "</span>,</span><br><span class="line">    props.name</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> element = Didact.createElement(App, &#123;</span><br><span class="line">  name: <span class="string">"foo"</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>函数式组件在以下两个方面与普通组件有所区别:</p>
<ul>
<li>函数式组件的 fiber 不存在 DOM 节点.</li>
<li>它的子元素的产生来自于函数式组件的执行, 而不是通过 <code>props</code> 传入</li>
</ul>
<p>在 <code>performUnitOfWork</code> 函数中, 我们检查 fiber 的类型是否是函数, 根据结果执行不同的更新操作.</p>
<p>拆分出函数式组件的处理方法 <code>updateHostComponent</code> 和普通组件 的处理方法<code>updateHostComponent</code>.</p>
<p><code>updateHostComponent</code> 所做的工作与原来一致:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostComponent</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber.dom) &#123;</span><br><span class="line">    fiber.dom = createDom(fiber)</span><br><span class="line">  &#125;</span><br><span class="line">  reconcileChildren(fiber, fiber.props.children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>updateFunctionComponent</code> 中, 我们执行这个函数组件以获取子元素. </p>
<p>在我们的例子中, <code>fiber.type</code> 的值为 <code>App</code> 函数, 执行它时, 会返回 <code>h1</code> 元素.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateFunctionComponent</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> children = [fiber.type(fiber.props)]</span><br><span class="line">  reconcileChildren(fiber, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取到子元素之后, 协调的工作还是和前一个版本没有区别, 因此不需要做出修改.</p>
<p>接下来需要修改的是 <code>commitWork</code> 函数.</p>
<p>开始处理没有 DOM 节点属性的 fibers, 需要修改两处:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> domParent = fiber.parent.dom</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    fiber.effectTag === <span class="string">"PLACEMENT"</span> &amp;&amp;</span><br><span class="line">    fiber.dom != <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    domParent.appendChild(fiber.dom)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    fiber.effectTag === <span class="string">"UPDATE"</span> &amp;&amp;</span><br><span class="line">    fiber.dom != <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    updateDom(</span><br><span class="line">      fiber.dom,</span><br><span class="line">      fiber.alternate.props,</span><br><span class="line">      fiber.props</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.effectTag === <span class="string">"DELETION"</span>) &#123;</span><br><span class="line">    domParent.removeChild(fiber.dom)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  commitWork(fiber.child)</span><br><span class="line">  commitWork(fiber.sibling)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先要找到 DOM 节点的父节点, 在 fiber 树中不断向上寻找直到找到一个存在 DOM 节点的 fiber.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> domParentFiber = fiber.parent</span><br><span class="line">  <span class="keyword">while</span> (!domParentFiber.dom) &#123;</span><br><span class="line">    domParentFiber = domParentFiber.parent</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> domParent = domParentFiber.dom</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    fiber.effectTag === <span class="string">"PLACEMENT"</span> &amp;&amp;</span><br><span class="line">    fiber.dom != <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    domParent.appendChild(fiber.dom)</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除节点也是, 需要不断寻找知道找到存在 DOM 节点的 fiber.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> domParent = fiber.parent.dom</span><br><span class="line">   <span class="keyword">if</span>(xxx) &#123;</span><br><span class="line">    <span class="comment">// xxx</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.effectTag === <span class="string">"DELETION"</span>) &#123;</span><br><span class="line">    domParent.removeChild(fiber.dom)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  commitWork(fiber.child)</span><br><span class="line">  commitWork(fiber.sibling)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitDeletion</span>(<span class="params">fiber, domParent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fiber.dom) &#123;</span><br><span class="line">    domParent.removeChild(fiber.dom)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    commitDeletion(fiber.child, domParent)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><p>最后一步是实现为函数式组件添加状态. </p>
<p>现在我们将 app 示例进行修改, 改为一个比较经典的计数器应用. 每一次点击计数器的数值就会加上1. </p>
<p>我们使用 <code>Didact.useState</code> 来读取和更新计数器的值.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@jsx </span>Didact.createElement */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = Didact.useState(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;h1 onClick=&#123;() =&gt; setState(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>)&#125;&gt;</span><br><span class="line">      Count: &#123;state&#125;</span><br><span class="line">    &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">const element = &lt;Counter /</span>&gt;</span><br></pre></td></tr></table></figure>
<p>接下来开始实现 <code>useState</code> 方法.</p>
<p>在调用函数式组件之前, 我们需要初始化一些全局变量, 然后在 <code>useState</code> 方法中使用它们.</p>
<p>首先我们设置正在工作的 fiber (<code>wipFiber</code>). </p>
<p>为这个 filber 设置 <code>hooks</code> 属性以支持 <code>useState</code> 在同一个组件中多次被调用, 由于被调用多次, 我们还需要关注当前的 hook 索引.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wipFiber = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> hookIndex = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateFunctionComponent</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  wipFiber = fiber</span><br><span class="line">  hookIndex = <span class="number">0</span></span><br><span class="line">  wipFiber.hooks = []</span><br><span class="line">  <span class="keyword">const</span> children = [fiber.type(fiber.props)]</span><br><span class="line">  reconcileChildren(fiber, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当函数式组件调用 <code>useState</code> 时, 我们会检查是否有一个旧的 hook 存在. 通过 fiber 的 <code>alternate</code> 和 hook 索引得到我们想要的结果.</p>
<p>如果存在一个旧的 hook, 那么我们就会将旧 hook 所存储的 state 拷贝到新的 hook 中. 如果不存在的话, 则初始化一个 state.</p>
<p>然后添加新的 hook 到 fiber 中, index 加上1, 然后返回这个 state.</p>
<p><code>useState</code> 同时还需要返回一个函数, 用以更新 state. 于是我们定义一个 <code>setState</code> 方法. 接受一个 action 作为参数, 在计数器的例子中, 这个 action 是每次点击为数字的值增加1.</p>
<p>我们给 <code>hook</code> 添加一个 队列 <code>queue</code> 属性, 每次用户调用 <code>setState</code>, 就把这个 action 添加到队列中.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setState = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  hook.queue.push(action);</span><br><span class="line">  wipRoot = &#123;</span><br><span class="line">    dom: currentRoot.dom,</span><br><span class="line">    props: currentRoot.props,</span><br><span class="line">    alternate: currentRoot</span><br><span class="line">  &#125;;</span><br><span class="line">  nextUnitOfWork = wipRoot;</span><br><span class="line">  deletions = [];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>将这个 action 添加到 <code>hook</code> 的属性 <code>queue</code> 中.</p>
<p>接下来做一些与在 <code>render</code> 函数中类似的事情. 设置一个新的追踪节点(<code>wipRoot</code>), 在下一次工作进程开始时, 循环中可以开始一次新的渲染流程.</p>
<p>接下来是执行 action, 在下一次组件重新渲染时, 我们会从旧的 hook 队列中读取到所有 action. 之后我们会在新的 hook 状态中一一执行这些 action, 然后返回最新的状态.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> oldHook =</span><br><span class="line">    wipFiber.alternate &amp;&amp;</span><br><span class="line">    wipFiber.alternate.hooks &amp;&amp;</span><br><span class="line">    wipFiber.alternate.hooks[hookIndex]</span><br><span class="line">  <span class="keyword">const</span> hook = &#123;</span><br><span class="line">    state: oldHook ? oldHook.state : initial,</span><br><span class="line">    queue: [],</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> actions = oldHook ? oldHook.queue : []</span><br><span class="line">  actions.forEach(<span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    hook.state = action(hook.state)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> setState = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    hook.queue.push(action)</span><br><span class="line">    wipRoot = &#123;</span><br><span class="line">      dom: currentRoot.dom,</span><br><span class="line">      props: currentRoot.props,</span><br><span class="line">      alternate: currentRoot,</span><br><span class="line">    &#125;</span><br><span class="line">    nextUnitOfWork = wipRoot</span><br><span class="line">    deletions = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  wipFiber.hooks.push(hook)</span><br><span class="line">  hookIndex++</span><br><span class="line">  <span class="keyword">return</span> [hook.state, setState]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终版本的代码: <a href="https://codesandbox.io/s/didact-8-21ost" target="_blank" rel="noopener">React With Hooks</a></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这篇文章除了帮助大家理解 React 的实现原理之外, 还有一个目的就是希望大家在阅读完之后能更容易地探索 React 源码. 这也是我们在文章中使用与源码一致的变量名和函数名的原因.</p>
<p>举个例子, 如果你在实际的 React 应用中, 在函数式组件里添加断点, 调用栈就会是如下这样:</p>
<ul>
<li><code>workLoop</code></li>
<li><code>performUnitOfWork</code></li>
<li><code>updateFunctionComponent</code></li>
</ul>
<p>当然, 教程中并没有覆盖到全部的 React 特性以及优化点. 举个例子, 下面是 React 与我们的源码实现地不同的地方:</p>
<ul>
<li>在 Didact 中, 我们在 <code>render</code> 阶段遍历了整个树. 而 React 并不会这样做, 当子树没有任何变化的话, 某些不必要的渲染流程就会被跳过.</li>
<li>同时在提交阶段, 我们也遍历了整个树, 而 React 则是维护了一个链表, 只关注有 <code>effectTag</code> 的 fiber, 只遍历这些 fiber.</li>
<li>每次我们创建一个新的工作节点时, 都会在每个 fiber 中创建新的对象. 而 React 则会从先前的树中回收这些 fiber.</li>
<li>当 Didact 在 <code>render</code> 阶段执行一次更新时, 会将追踪工作树完全移除, 然后从根节点再重新开始流程. 而 React 的每一个 tag 则是维护了一个时间戳, 根据是否超时来确定此次更新的优先级.</li>
<li>以及更多……</li>
</ul>
<p>你还可以很方便地添加 React 相关的其他特性:</p>
<ul>
<li>处理值为对象的 <code>style</code> 属性</li>
<li><a href="https://github.com/pomber/didact/issues/11" target="_blank" rel="noopener">实现子元素的扁平化</a></li>
<li><code>useEffect</code></li>
<li>根据 key 进行协调</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/posts/2021/04/19/ssr-render-html-string/" class="prev">PREV</a><a href="/posts/2020/01/22/how-does-setstate-know-what-to-do/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 - 2023 <a href="https://icyfish.github.io/posts">Fish</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>