---
title: constructor
date: 2019-02-14
permalink: constructor
---


[Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)

Class是原型链继承的语法糖.

## 定义class

Class是特殊的函数, 函数有函数表达式, 和函数声明. class语法也存在这两种形式:

### class声明

下面声明了`Rectangle`class:

```js
class Rectangle {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
}
```

**声明提前**

函数声明与class声明最主要的区别是函数声明会被提前但是class声明不会. 我们必须首先声明class, 之后才可以获取它, 否则会抛出`ReferenceError`错误: 

```js
const p = new Rectangle(); // ReferenceError

class Rectangle {}
```

### Class表达式

class表达式是另一种定义class的方式, 可以命名也可匿名. The name given to a named class expression is local to the class's body. (it can be retrieved through the class's (not an instance's) name property, though). class表达式同样不遵循声明提前的规则.

```js
// unnamed
let Rectangle = class {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
};
console.log(Rectangle.name);
// output: "Rectangle"

// named
let Rectangle = class Rectangle2 {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
};
console.log(Rectangle.name);
// output: "Rectangle2"
```

## Class体与方法定义

class体是`{}`大括号中的内容. 我们在里面定义方法或构造器.

### 严格模式

class的执行遵循严格模式, 简单来说: 为了性能考虑, 代码的执行遵循更加严格的语法, 因此代码里含有某些不严格的语法时会报错, 同时某些关键词被认为是保留词. 

### 构造器

`constructor`是一个特殊的方法, `class`中使用该方法创建和初始化一个对象. class体中只允许存在一个`constructor`. 如果存在多个的话会抛出`SyntaxError`. 构造器可以使用`super`关键词调用超类的构造器方法.

### 原型方法 Prototype 

```js
class Rectangle {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
  // Getter
  get area() {
    return this.calcArea();
  }
  // Method
  calcArea() {
    return this.height * this.width;
  }
}

const square = new Rectangle(10, 10);

console.log(square.area); // 100
```


### 静态方法 Static methods

我们使用`static`关键词为class定义静态方法. 调用静态方法时, 不会初始化class, 而且在class的实例中不可以调用这个静态方法. 静态方法常用来程序中创建util方法. 

```js
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  static distance(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;

    return Math.hypot(dx, dy);
  }
}

const p1 = new Point(5, 5);
const p2 = new Point(10, 10);

console.log(Point.distance(p1, p2)); // 7.0710678118654755
```

TO Be Continued 

[Boxing with prototype and static methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Boxing_with_prototype_and_static_methods)


## Questions

- [The Objects](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects#The_object_(class_instance))
- [strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)
- [method definitions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions) getter setter
