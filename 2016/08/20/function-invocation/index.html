<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="IDYUPnBNhdnU8o9LRNKZ1RSt14tIxTI0rLeMrBtswXw"><title> JavaScript中四种函数调用模式 · Fish</title><meta name="description" content="JavaScript中四种函数调用模式 - Fish"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/posts/favicon.png"><link rel="stylesheet" href="/posts/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://icyfish.github.io/posts/atom.xml" title="Fish"><meta name="generator" content="Hexo 7.0.0-rc1"></head><body><div class="wrap"><header><a href="/posts/" class="logo-link"><img src="/posts/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/posts/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/posts/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/posts/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="http://twitter.com/icyfish_" target="_blank" class="nav-list-link">TWITTER</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">JavaScript中四种函数调用模式</h1><div class="post-info">Aug 20, 2016</div><div class="post-content"><p>在JavaScript中对函数进行调用有多种方式, 以下是对四种函数调用模式的介绍, 以及call, apply, bind的区别.</p>
<a id="more"></a>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>当一个函数被保存为对象的一个属性时,我们称它为一个方法,当一个方法被调用时,this被绑定到该对象.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建myObject.它有一个value属性和一个increment方法.</span></span><br><span class="line"><span class="comment">//increment方法接受一个可选的参数.如果参数不是数字,那么默认使用数字1.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    value: <span class="number">0</span>,</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span> (<span class="params">inc</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value += <span class="keyword">typeof</span> inc === <span class="string">'number'</span> ? inc : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject.increment();</span><br><span class="line"><span class="built_in">console</span>.log(myObject.value); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">myObject.increment(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(myObject.value); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>this直接修改了该对象的value属性,所以第二次调用increment是在value == 1的基础上增加.</p>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>此模式为最常见的调用模式.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showThis</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">showThis();</span><br><span class="line"><span class="comment">//返回Window&#123;...&#125;</span></span><br></pre></td></tr></table></figure>
<p>当函数以此模式调用时,this被绑定到全局对象.在浏览器中,全局对象为Window.this绑定到全局对象是语言设计上的一个错误,当内部函数被调用时,this应该仍然绑定到外部函数的this变量.这个设计错误的后果是方法不能利用内部函数来帮助它工作,因为内部函数的this被绑定了错误值,不能共享该方法对对象的访问权,不过有个很容易的解决方案,在对象的方法内定义一个变量并给它赋值为this,那么内部函数就能通过那个变量访问到this.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    value: <span class="number">0</span>,</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span> (<span class="params">inc</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value += <span class="keyword">typeof</span> inc === <span class="string">'number'</span> ? inc : <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    getValue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject.double = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>; <span class="comment">//解决方法</span></span><br><span class="line">    <span class="keyword">var</span> helper  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        that.value = add(that.value,that.value);</span><br><span class="line">        <span class="comment">//alert(this); //用以测试this的值,在浏览器中会弹出object Window</span></span><br><span class="line">    &#125;;</span><br><span class="line">    helper(); <span class="comment">//以函数形式调用helper</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myObject.increment();</span><br><span class="line">myObject.increment(<span class="number">2</span>);</span><br><span class="line">myObject.double();</span><br><span class="line"><span class="built_in">console</span>.log(myObject.getValue()); <span class="comment">//6</span></span><br></pre></td></tr></table></figure>
<p>上例在给myObject增加double方法的函数中创建了一个内部函数helper,但helpler无法直接用this访问到myObject对象中的value属性,因为在helper中this为全局对象,可以在helper中添加alert(this)测试.为了让helper访问到外部函数myObject.double的this值,定义了一个变量that来保存this值,这个this值为myObject.</p>
<h2 id="构造器调用"><a href="#构造器调用" class="headerlink" title="构造器调用"></a>构造器调用</h2><p>如果在一个函数前面带上new来调用,那么将创建一个隐藏连接到该函数的prototype成员的新对象,同时this将会被绑定到那个新对象上.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个名为Quo的构造器函数,它构造一个带有status属性的对象.</span></span><br><span class="line"><span class="keyword">var</span> Quo = <span class="function"><span class="keyword">function</span>(<span class="params">string</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.status = string;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给Quo的所有示例提供一个名为getStatus的公共方法.</span></span><br><span class="line">Quo.prototype.getStatus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个Quo实例</span></span><br><span class="line"><span class="keyword">var</span> myQuo = <span class="keyword">new</span> Quo(<span class="string">"confused"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(myQuo.getStatus());</span><br></pre></td></tr></table></figure>
<h2 id="call调用和apply调用"><a href="#call调用和apply调用" class="headerlink" title="call调用和apply调用"></a>call调用和apply调用</h2><p>因为JavaScript是一门函数式的面向对象编程语言,所以函数也是对象,可以拥有方法.</p>
<p><strong>bind(), apply(), call()</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstname: <span class="string">'John'</span>,</span><br><span class="line">  lastname: <span class="string">'Doe'</span>,</span><br><span class="line">  getFullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fullname = <span class="keyword">this</span>.firstname + <span class="string">" "</span> + <span class="keyword">this</span>.lastname;</span><br><span class="line">    <span class="keyword">return</span> fullname;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logName = <span class="function"><span class="keyword">function</span>(<span class="params">lang1, lang2</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Logged: '</span> + <span class="keyword">this</span>.getFullName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logPersonName = logName.bind(person); <span class="comment">// &#123;1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// logName(); //Error: this.getFullName is not a function at logName // &#123;2&#125;</span></span><br><span class="line"></span><br><span class="line">logPersonName(); <span class="comment">// Logged: John Doe</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// var logName = function(lang1, lang2)&#123;</span></span><br><span class="line"><span class="comment">//   console.log('Logged: ' + this.getFullName());</span></span><br><span class="line"><span class="comment">// &#125;.bind(person); // &#123;3&#125;</span></span><br><span class="line"></span><br><span class="line">logName.call(person, <span class="string">'en'</span>, <span class="string">'es'</span>);</span><br><span class="line">logName.apply(person, [<span class="string">'en'</span>, <span class="string">'es'</span>]);</span><br></pre></td></tr></table></figure>
<p>行{1}利用bind方法, 在参数内传入<code>person</code>对象, 将this值绑定到<code>person</code>, 此时<code>getFullName()</code>就可以正常执行. 如果像行{2}那样直接执行, 那么this指向的就是全局对象<code>window</code>, 而window中没有定义<code>firstname</code>,<code>getFullName()</code>,<code>lastname</code>, 因此会抛出错误. 还可以像行{3}那样绑定this.</p>
<ul>
<li>bind方法返回一个新的函数, 是原函数的拷贝.</li>
<li>call和apply直接调用函数执行</li>
</ul>
<p>在call和apply中传入的第一个参数为this需要绑定到的对象, 后面为传入函数的参数, call和apply唯一的区别就是传入apply中的参数为数组. call和apply第二个及之后的参数是可选参数, 也可以不传入直接执行.</p>
<p><strong>应用</strong></p>
<h3 id="function-borrowing"><a href="#function-borrowing" class="headerlink" title="function borrowing"></a>function borrowing</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstname: <span class="string">'John'</span>,</span><br><span class="line">  lastname: <span class="string">'Doe'</span>,</span><br><span class="line">  getFullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fullname = <span class="keyword">this</span>.firstname + <span class="string">' '</span> + <span class="keyword">this</span>.lastname;</span><br><span class="line">    <span class="keyword">return</span> fullname;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  firstname: <span class="string">'Jane'</span>,</span><br><span class="line">  lastname: <span class="string">'Doe'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.getFullName.apply(person2));</span><br><span class="line"><span class="built_in">console</span>.log(person.getFullName.call(person2));</span><br></pre></td></tr></table></figure>
<p>利用apply和call从<code>person</code>对象中’借’<code>getFullName</code>方法.</p>
<h3 id="function-currying"><a href="#function-currying" class="headerlink" title="function currying"></a>function currying</h3><p>函数柯里化:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> multiplyByTwo = multiply.bind(<span class="keyword">this</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> multiplyByThree = multiply.bind(<span class="keyword">this</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(multiplyByTwo(<span class="number">2</span>)); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//给bind()传入第二个参数,第二个参数成为函数对象第一个参数的默认值,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// multiplyByTwo相当于:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function multiplyByTwo(b)&#123;</span></span><br><span class="line"><span class="comment">//   var a = 2;</span></span><br><span class="line"><span class="comment">//   return a * b;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以传入多个参数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(multiply.bind(<span class="keyword">this</span>, <span class="number">2</span>, <span class="number">3</span>)()); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>柯里化: 创建函数的拷贝, 在该拷贝中传入部分预设参数(creating a copy of a function but with some preset parameters), 常用于有许多有关数学计算的场景中.</p>
</div></article></div></main><footer><div class="paginator"><a href="/posts/2016/09/02/scope-of-variables/" class="prev">PREV</a></div><div class="copyright"><p>© 2019 - 2023 <a href="https://icyfish.github.io/posts">Fish</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>