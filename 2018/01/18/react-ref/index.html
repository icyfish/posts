<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="IDYUPnBNhdnU8o9LRNKZ1RSt14tIxTI0rLeMrBtswXw"><title> React Ref · Fish</title><meta name="description" content="React Ref - Fish"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/posts/favicon.png"><link rel="stylesheet" href="/posts/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://icyfish.github.io/posts/atom.xml" title="Fish"><meta name="generator" content="Hexo 7.0.0-rc1"></head><body><div class="wrap"><header><a href="/posts/" class="logo-link"><img src="/posts/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/posts/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/posts/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/posts/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="http://twitter.com/icyfish_" target="_blank" class="nav-list-link">TWITTER</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">React Ref</h1><div class="post-info">Jan 18, 2018</div><div class="post-content"><p>引用某个react UI组件的时候遇到了这样的告警: addComponentAsRefTo(…): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component’s render method, or you have multiple copies of React loaded. </p>
<p>于是去了解了一下ref的用法:</p>
<a id="more"></a>
<h2 id="Refs-and-the-DOM"><a href="#Refs-and-the-DOM" class="headerlink" title="Refs and the DOM"></a>Refs and the DOM</h2><p>React的典型数据传递方式是通过props将数据从父组件传给子组件. 一旦props更新, 子组件重新渲染. 但在某些情况下, 开发者会想要不通过props传递数据更新, 而是直接更新子组件. 这些子组件可以是React组件的实例或者是DOM元素. 对于以上这两种子组件, React提供了一种直接更新的方法: 使用<code>refs</code>.</p>
<h3 id="何时使用refs"><a href="#何时使用refs" class="headerlink" title="何时使用refs"></a>何时使用refs</h3><ul>
<li>处理聚焦, 文本选择, 影音播放</li>
<li>触发imperative animation <a href="https://anvaka.github.io/sj/compare/" target="_blank" rel="noopener">参考</a></li>
<li>与第三方DOM库结合使用时</li>
</ul>
<p>如果操作可以使用说明式方式完成(things can be done declaratively), 尽量使用说明式, 避免使用refs.</p>
<p>比如, 在<code>Dialog</code>组件中, 能够通过传<code>isOpen</code>属性完成的操作, 就不要暴露<code>open()</code>, <code>close()</code>方法执行. </p>
<h3 id="不要滥用refs"><a href="#不要滥用refs" class="headerlink" title="不要滥用refs"></a>不要滥用refs</h3><p>开发者很容易滥用refs来处理问题, 但更好的方式是考虑清楚各个组件层级应该拥有的state, 使不同层级的组件拥有不同的state使得应用更加清晰有条理, 易于开发维护. <a href="https://reactjs.org/docs/lifting-state-up.html" target="_blank" rel="noopener">处理state相关例子</a></p>
<h3 id="添加ref到DOM元素中"><a href="#添加ref到DOM元素中" class="headerlink" title="添加ref到DOM元素中"></a>添加ref到DOM元素中</h3><p><code>ref</code>是React组件中的一个特殊属性, 该属性接受一个回调函数, 在该组件 mount/unmount 的时候回调函数会立即执行. </p>
<p>当<code>ref</code>属性用在HTML元素中时, <code>ref</code>回调函数的参数是该DOM元素. 以下代码中, 使用<code>ref</code>存储了DOM节点(第一个<code>input</code>)的引用. </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.focusTextInput = <span class="keyword">this</span>.focusTextInput.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  focusTextInput() &#123;</span><br><span class="line">    <span class="comment">// 使用DOM API 显式聚焦第一个`input`元素的文本</span></span><br><span class="line">    <span class="keyword">this</span>.textInput.focus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 使用`ref`将DOM节点(第一个`input`)的引用存储到this.textInput</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          ref=&#123;(input) =&gt; &#123; <span class="keyword">this</span>.textInput = input; &#125;&#125; /&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"button"</span></span><br><span class="line">          value=<span class="string">"Focus the text input"</span></span><br><span class="line">          onClick=&#123;<span class="keyword">this</span>.focusTextInput&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>当以上<code>CustomTextInput</code>组件mount时, React会调用<code>ref</code>回调函数, 当unmount时, 传入参数<code>null</code>调用. 分别在<code>componentDidMount</code>, <code>componentDidUpdate</code>这两个生命周期中.</p>
<p>在React组件内部使用<code>ref</code>使用是获取DOM元素的常用方式, 以回调的形式(如上例)使用该属性是推荐方式. 更加简洁的推荐使用方式: <code>ref={input =&gt; this.textInput = input}</code>.</p>
<h3 id="在class组件中添加ref"><a href="#在class组件中添加ref" class="headerlink" title="在class组件中添加ref"></a>在class组件中添加ref</h3><p>在类组件中使用<code>ref</code>属性时, <code>ref</code>回调接受已经mount的组件实例作为其参数. 如果我们想要实现上例中的<code>CustomTextInput</code>在mount之后立即模拟被点击, 可以这样做:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoFocusTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.textInput.focusTextInput();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;CustomTextInput</span><br><span class="line">        ref=&#123;(input) =&gt; &#123; <span class="keyword">this</span>.textInput = input; &#125;&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意<code>CustomTextInput</code>只有在被声明为class组件时, 这种情况才生效.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Refs-和-Functional-组件"><a href="#Refs-和-Functional-组件" class="headerlink" title="Refs 和 Functional 组件"></a>Refs 和 Functional 组件</h3><p>因为funtional组件没有实例, 因此不可以在其中使用<code>ref</code>属性. </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyFunctionalComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 不可以这样做:</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;MyFunctionalComponent</span><br><span class="line">        ref=&#123;(input) =&gt; &#123; <span class="keyword">this</span>.textInput = input; &#125;&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过在functional组件中的DOM元素或class组件中, 可以使用<code>ref</code>属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomTextInput</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// textInput 必须在此处声明, 这样ref回调函数才可以引用它 </span></span><br><span class="line">  <span class="keyword">let</span> textInput = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    textInput.focus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">"text"</span></span><br><span class="line">        ref=&#123;(input) =&gt; &#123; textInput = input; &#125;&#125; /&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">"button"</span></span><br><span class="line">        value=<span class="string">"Focus the text input"</span></span><br><span class="line">        onClick=&#123;handleClick&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );  </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="将DOM-ref暴露给父组件"><a href="#将DOM-ref暴露给父组件" class="headerlink" title="将DOM ref暴露给父组件"></a>将DOM ref暴露给父组件</h3><p>在有些情况下(但极少), 开发者需要在父组件中获取子组件的DOM节点. 一般来说这种方法是不推荐的, 因为违背了组件封装的原则, 可是在某些情况下, 却不得不用到这种方法, 比如触发聚焦或计算子组件DOM节点的大小与位置. </p>
<p>开发者可以给子组件添加<code>ref</code>属性(见在class组件中添加ref), 但这并不是理想的解决方式, 因为这种方式只能够获取到组件的实例, 而不是DOM节点, 此外, 如果子组件是functional组件, 这种方法也不会生效. </p>
<p>因此在这种情况下, React推荐开发者在子组件中暴露一个特殊的属性. 该组组件接受一个名为<code>inputRef</code>的函数属性. React会对其进行处理, 然后将<code>ref</code>属性添加到该组件下的DOM节点上. 这样, 父组件就能够将<code>ref</code>回调传给子组件的DOM节点, 见下例:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomTextInput</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input ref=&#123;props.inputRef&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Parent extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;CustomTextInput</span></span><br><span class="line"><span class="regexp">        inputRef=&#123;el =&gt; this.inputElement = el&#125;</span></span><br><span class="line"><span class="regexp">      /</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上例子中, <code>Parent</code>组件将ref回调通过<code>inputRef</code>属性传给<code>CustomTextInput</code>, <code>CustomTextInput</code>再将该回调以<code>ref</code>属性的方式传给<code>&lt;input&gt;</code>. 最终, 父组件<code>Parent</code>中的<code>this.inputElement</code>的值就是子组件<code>CustomTextInput</code>下<code>&lt;input&gt;</code>元素.</p>
<p>注意以上例子中, 属性<code>inputRef</code>没有特殊意义, 就是组件的一般属性. 不过, 必须要在<code>&lt;input&gt;</code>元素本身使用<code>ref</code>属性, 这样React才会将该属性与DOM节点关联.</p>
<p>即使<code>CustomTextInput</code>是functional组件, 以上的例子也会生效. <code>ref</code>是有特定含义的属性, 只能够在DOM元素和class组件中使用, <code>inputRef</code><br>没有特定含义, 只是一般的属性, 因此在组件中都可以使用, 没有使用上的限制.</p>
<p>这种模式的另一个优点是: 可以深入多层级的组件. 比如, 在<code>Parent</code>组件中不需要获取其子组件的DOM节点, 但包含<code>Parent</code>组件的<code>GrandParent</code>组件需要获取, 这时也可以使用<code>inputRef</code>来DOM节点. 例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomTextInput</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input ref=&#123;props.inputRef&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Parent(props) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      My input: &lt;CustomTextInput inputRef=&#123;props.inputRef&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Grandparent extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;Parent</span></span><br><span class="line"><span class="regexp">        inputRef=&#123;el =&gt; this.inputElement = el&#125;</span></span><br><span class="line"><span class="regexp">      /</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时, ref回调是在<code>Grandparent</code>组件中首次声明, 通过<code>inputRef</code>一层层传到<code>CustomTextInput</code>, 使得<code>Grandparent</code>组件通过<code>this.inputElement</code>获取到<code>&lt;input&gt;</code>元素. </p>
<p>总的来说, 我们是反对暴露DOM节点的, 但特殊情况总是免不了, 此时就要使用以上的方法. 注意这种方式要求你在子组件中添加一些代码, 如果你无法控制子组件, 还有另外一种方式<a href="https://reactjs.org/docs/react-dom.html#finddomnode" target="_blank" rel="noopener">findDOMNode()</a>, 但不推荐使用这种方式. </p>
<h3 id="过时API-字符串ref"><a href="#过时API-字符串ref" class="headerlink" title="过时API: 字符串ref"></a>过时API: 字符串ref</h3><p>过去将ref以字符串的形式声明, <code>ref=&quot;textInput</code>, 然后通过<code>this.refs.textInput</code>获取相应的DOM节点. 但现在这种方法不被推荐使用, 因为字符串形式的ref会引起<a href="https://github.com/facebook/react/pull/8333#issuecomment-271648615" target="_blank" rel="noopener">一些问题</a>, 所以React团队不推荐这种用法, 在将来的版本中或许会完全抛弃. </p>
<h3 id="一个小问题"><a href="#一个小问题" class="headerlink" title="一个小问题"></a>一个小问题</h3><p>如果<code>ref</code>函数以inline函数的方式定义, 它会被调用两次, 第一次的参数是<code>null</code>, 第二次是DOM元素. 这是因为每一次渲染都会创建一个函数的实例, React需要清除旧的<code>ref</code>然后重新设置一个新的<code>ref</code>. 以<code>bound method</code>的方式定义<code>ref</code>回调函数可以避免这个问题, 不过在大部分情况下, 即使以inline函数的方式定义, 也不会引起什么问题. </p>
<h2 id="Refs-Must-Have-Owner"><a href="#Refs-Must-Have-Owner" class="headerlink" title="Refs Must Have Owner"></a>Refs Must Have Owner</h2><p>开发过程中遇到了以下警告: </p>
<p>React 16.0.0+ 版本中:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Warnin<span class="variable">g:</span></span><br><span class="line"></span><br><span class="line">Element ref was specified <span class="keyword">as</span> <span class="keyword">a</span> <span class="built_in">string</span></span><br><span class="line">(myRefName) but <span class="keyword">no</span> owner was <span class="keyword">set</span>. </span><br><span class="line">You may have multiple copies of React loaded. (detail<span class="variable">s:https</span>://fb.<span class="keyword">me</span>/react-refs-must-have-owner).</span><br></pre></td></tr></table></figure>
<p>旧版本:</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Warning:</span><br><span class="line"></span><br><span class="line">addComponentAsRefTo(…): </span><br><span class="line">Only a ReactOwner can have refs. </span><br><span class="line">You might be adding a ref <span class="keyword">to</span> a component</span><br><span class="line">that was <span class="keyword">not</span> created inside a component’s </span><br><span class="line">render <span class="function"><span class="keyword">method</span>, </span></span><br><span class="line"><span class="function"><span class="title">or</span> <span class="title">you</span> <span class="title">have</span> <span class="title">multiple</span> <span class="title">copies</span> <span class="title">of</span> <span class="title">React</span> <span class="title">loaded</span>.</span></span><br></pre></td></tr></table></figure>
<p>一般是由以下三种原因导致的:</p>
<ul>
<li>在fuctionnal组件中添加<code>ref</code>属性</li>
<li>在组件的<code>render()</code>函数之外创建了一个元素, 在该元素中添加了<code>ref</code>属性</li>
<li>加载了多个React的拷贝(其中一个可能原因是npm依赖配置错误)</li>
</ul>
<h3 id="在funtional组件中添加ref"><a href="#在funtional组件中添加ref" class="headerlink" title="在funtional组件中添加ref"></a>在funtional组件中添加ref</h3><p>如果组件<code>&lt;Foo&gt;</code>是functional组件, 不可以这样添加ref:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Foo ref=&#123;foo&#125; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="在render方法之外添加值为字符串形式的ref属性"><a href="#在render方法之外添加值为字符串形式的ref属性" class="headerlink" title="在render方法之外添加值为字符串形式的ref属性"></a>在render方法之外添加值为字符串形式的ref属性</h3><p>当开发者添加了值为字符串的ref属性到了一个没有父组件的组件中(即该组件不在父组件的<code>render</code>方法内创建)</p>
<p>不可以这样添加 ref:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">ref</span>=<span class="string">"app"</span> /&gt;</span></span>, el);</span><br></pre></td></tr></table></figure>
<p>正确方式: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> app;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;App ref=&#123;inst =&gt; &#123;</span><br><span class="line">    app = inst;</span><br><span class="line">  &#125;&#125; /&gt;,</span><br><span class="line">  el</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="多个React拷贝"><a href="#多个React拷贝" class="headerlink" title="多个React拷贝"></a>多个React拷贝</h3><p>Bower在删除重复数据方面处理得很好, 可是npm并不. 如果调试之后发现不是<code>ref</code>的用法出了问题, 那很可能就是因为项目中加载了多个React的拷贝. 这种问题常常在项目中引入第三方库的时候出现. </p>
<p>在命令行中输入<code>npm ls react</code>可以查看项目中存在的react版本. </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://reactjs.org/docs/refs-and-the-dom.html#refs-and-functional-components" target="_blank" rel="noopener">Refs and the DOM</a></p>
</li>
<li><p><a href="https://reactjs.org/warnings/refs-must-have-owner.html" target="_blank" rel="noopener">Refs Must Have Owner</a></p>
</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/posts/2018/02/07/css-position/" class="prev">PREV</a><a href="/posts/2018/01/02/iterators-and-the-for-of-loop/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 - 2023 <a href="https://icyfish.github.io/posts">Fish</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>